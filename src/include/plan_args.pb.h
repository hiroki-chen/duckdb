// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plan_args.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_plan_5fargs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_plan_5fargs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
#include "transform.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_plan_5fargs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_plan_5fargs_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_plan_5fargs_2eproto;
namespace PicachvMessages {
class AggregateArgument;
struct AggregateArgumentDefaultTypeInternal;
extern AggregateArgumentDefaultTypeInternal _AggregateArgument_default_instance_;
class GetDataArgument;
struct GetDataArgumentDefaultTypeInternal;
extern GetDataArgumentDefaultTypeInternal _GetDataArgument_default_instance_;
class GetDataFromFileArgument;
struct GetDataFromFileArgumentDefaultTypeInternal;
extern GetDataFromFileArgumentDefaultTypeInternal _GetDataFromFileArgument_default_instance_;
class GetDataInMemory;
struct GetDataInMemoryDefaultTypeInternal;
extern GetDataInMemoryDefaultTypeInternal _GetDataInMemory_default_instance_;
class GetDataInMemory_ProjectList;
struct GetDataInMemory_ProjectListDefaultTypeInternal;
extern GetDataInMemory_ProjectListDefaultTypeInternal _GetDataInMemory_ProjectList_default_instance_;
class HstackArgument;
struct HstackArgumentDefaultTypeInternal;
extern HstackArgumentDefaultTypeInternal _HstackArgument_default_instance_;
class PlanArgument;
struct PlanArgumentDefaultTypeInternal;
extern PlanArgumentDefaultTypeInternal _PlanArgument_default_instance_;
class ProjectionArgument;
struct ProjectionArgumentDefaultTypeInternal;
extern ProjectionArgumentDefaultTypeInternal _ProjectionArgument_default_instance_;
class SelectArgument;
struct SelectArgumentDefaultTypeInternal;
extern SelectArgumentDefaultTypeInternal _SelectArgument_default_instance_;
class TransformArgument;
struct TransformArgumentDefaultTypeInternal;
extern TransformArgumentDefaultTypeInternal _TransformArgument_default_instance_;
}  // namespace PicachvMessages
PROTOBUF_NAMESPACE_OPEN
template<> ::PicachvMessages::AggregateArgument* Arena::CreateMaybeMessage<::PicachvMessages::AggregateArgument>(Arena*);
template<> ::PicachvMessages::GetDataArgument* Arena::CreateMaybeMessage<::PicachvMessages::GetDataArgument>(Arena*);
template<> ::PicachvMessages::GetDataFromFileArgument* Arena::CreateMaybeMessage<::PicachvMessages::GetDataFromFileArgument>(Arena*);
template<> ::PicachvMessages::GetDataInMemory* Arena::CreateMaybeMessage<::PicachvMessages::GetDataInMemory>(Arena*);
template<> ::PicachvMessages::GetDataInMemory_ProjectList* Arena::CreateMaybeMessage<::PicachvMessages::GetDataInMemory_ProjectList>(Arena*);
template<> ::PicachvMessages::HstackArgument* Arena::CreateMaybeMessage<::PicachvMessages::HstackArgument>(Arena*);
template<> ::PicachvMessages::PlanArgument* Arena::CreateMaybeMessage<::PicachvMessages::PlanArgument>(Arena*);
template<> ::PicachvMessages::ProjectionArgument* Arena::CreateMaybeMessage<::PicachvMessages::ProjectionArgument>(Arena*);
template<> ::PicachvMessages::SelectArgument* Arena::CreateMaybeMessage<::PicachvMessages::SelectArgument>(Arena*);
template<> ::PicachvMessages::TransformArgument* Arena::CreateMaybeMessage<::PicachvMessages::TransformArgument>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PicachvMessages {

// ===================================================================

class GetDataFromFileArgument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PicachvMessages.GetDataFromFileArgument) */ {
 public:
  inline GetDataFromFileArgument() : GetDataFromFileArgument(nullptr) {}
  ~GetDataFromFileArgument() override;
  explicit PROTOBUF_CONSTEXPR GetDataFromFileArgument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataFromFileArgument(const GetDataFromFileArgument& from);
  GetDataFromFileArgument(GetDataFromFileArgument&& from) noexcept
    : GetDataFromFileArgument() {
    *this = ::std::move(from);
  }

  inline GetDataFromFileArgument& operator=(const GetDataFromFileArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataFromFileArgument& operator=(GetDataFromFileArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataFromFileArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataFromFileArgument* internal_default_instance() {
    return reinterpret_cast<const GetDataFromFileArgument*>(
               &_GetDataFromFileArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetDataFromFileArgument& a, GetDataFromFileArgument& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataFromFileArgument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataFromFileArgument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataFromFileArgument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataFromFileArgument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataFromFileArgument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataFromFileArgument& from) {
    GetDataFromFileArgument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataFromFileArgument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PicachvMessages.GetDataFromFileArgument";
  }
  protected:
  explicit GetDataFromFileArgument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kDfUuidFieldNumber = 3,
    kFileTypeFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // bytes df_uuid = 3;
  void clear_df_uuid();
  const std::string& df_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_df_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_df_uuid();
  PROTOBUF_NODISCARD std::string* release_df_uuid();
  void set_allocated_df_uuid(std::string* df_uuid);
  private:
  const std::string& _internal_df_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_df_uuid(const std::string& value);
  std::string* _internal_mutable_df_uuid();
  public:

  // .PicachvMessages.FileType file_type = 2;
  void clear_file_type();
  ::PicachvMessages::FileType file_type() const;
  void set_file_type(::PicachvMessages::FileType value);
  private:
  ::PicachvMessages::FileType _internal_file_type() const;
  void _internal_set_file_type(::PicachvMessages::FileType value);
  public:

  // @@protoc_insertion_point(class_scope:PicachvMessages.GetDataFromFileArgument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr df_uuid_;
    int file_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class GetDataInMemory_ProjectList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PicachvMessages.GetDataInMemory.ProjectList) */ {
 public:
  inline GetDataInMemory_ProjectList() : GetDataInMemory_ProjectList(nullptr) {}
  ~GetDataInMemory_ProjectList() override;
  explicit PROTOBUF_CONSTEXPR GetDataInMemory_ProjectList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataInMemory_ProjectList(const GetDataInMemory_ProjectList& from);
  GetDataInMemory_ProjectList(GetDataInMemory_ProjectList&& from) noexcept
    : GetDataInMemory_ProjectList() {
    *this = ::std::move(from);
  }

  inline GetDataInMemory_ProjectList& operator=(const GetDataInMemory_ProjectList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataInMemory_ProjectList& operator=(GetDataInMemory_ProjectList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataInMemory_ProjectList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataInMemory_ProjectList* internal_default_instance() {
    return reinterpret_cast<const GetDataInMemory_ProjectList*>(
               &_GetDataInMemory_ProjectList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetDataInMemory_ProjectList& a, GetDataInMemory_ProjectList& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataInMemory_ProjectList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataInMemory_ProjectList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataInMemory_ProjectList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataInMemory_ProjectList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataInMemory_ProjectList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataInMemory_ProjectList& from) {
    GetDataInMemory_ProjectList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataInMemory_ProjectList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PicachvMessages.GetDataInMemory.ProjectList";
  }
  protected:
  explicit GetDataInMemory_ProjectList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectListFieldNumber = 1,
  };
  // repeated uint64 project_list = 1;
  int project_list_size() const;
  private:
  int _internal_project_list_size() const;
  public:
  void clear_project_list();
  private:
  uint64_t _internal_project_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_project_list() const;
  void _internal_add_project_list(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_project_list();
  public:
  uint64_t project_list(int index) const;
  void set_project_list(int index, uint64_t value);
  void add_project_list(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      project_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_project_list();

  // @@protoc_insertion_point(class_scope:PicachvMessages.GetDataInMemory.ProjectList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > project_list_;
    mutable std::atomic<int> _project_list_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class GetDataInMemory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PicachvMessages.GetDataInMemory) */ {
 public:
  inline GetDataInMemory() : GetDataInMemory(nullptr) {}
  ~GetDataInMemory() override;
  explicit PROTOBUF_CONSTEXPR GetDataInMemory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataInMemory(const GetDataInMemory& from);
  GetDataInMemory(GetDataInMemory&& from) noexcept
    : GetDataInMemory() {
    *this = ::std::move(from);
  }

  inline GetDataInMemory& operator=(const GetDataInMemory& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataInMemory& operator=(GetDataInMemory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataInMemory& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataInMemory* internal_default_instance() {
    return reinterpret_cast<const GetDataInMemory*>(
               &_GetDataInMemory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetDataInMemory& a, GetDataInMemory& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataInMemory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataInMemory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataInMemory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataInMemory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataInMemory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataInMemory& from) {
    GetDataInMemory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataInMemory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PicachvMessages.GetDataInMemory";
  }
  protected:
  explicit GetDataInMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetDataInMemory_ProjectList ProjectList;

  // accessors -------------------------------------------------------

  enum : int {
    kDfUuidFieldNumber = 1,
    kPredFieldNumber = 2,
    kProjectListFieldNumber = 3,
  };
  // bytes df_uuid = 1;
  void clear_df_uuid();
  const std::string& df_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_df_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_df_uuid();
  PROTOBUF_NODISCARD std::string* release_df_uuid();
  void set_allocated_df_uuid(std::string* df_uuid);
  private:
  const std::string& _internal_df_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_df_uuid(const std::string& value);
  std::string* _internal_mutable_df_uuid();
  public:

  // optional bytes pred = 2;
  bool has_pred() const;
  private:
  bool _internal_has_pred() const;
  public:
  void clear_pred();
  const std::string& pred() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pred(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pred();
  PROTOBUF_NODISCARD std::string* release_pred();
  void set_allocated_pred(std::string* pred);
  private:
  const std::string& _internal_pred() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pred(const std::string& value);
  std::string* _internal_mutable_pred();
  public:

  // optional .PicachvMessages.GetDataInMemory.ProjectList project_list = 3;
  bool has_project_list() const;
  private:
  bool _internal_has_project_list() const;
  public:
  void clear_project_list();
  const ::PicachvMessages::GetDataInMemory_ProjectList& project_list() const;
  PROTOBUF_NODISCARD ::PicachvMessages::GetDataInMemory_ProjectList* release_project_list();
  ::PicachvMessages::GetDataInMemory_ProjectList* mutable_project_list();
  void set_allocated_project_list(::PicachvMessages::GetDataInMemory_ProjectList* project_list);
  private:
  const ::PicachvMessages::GetDataInMemory_ProjectList& _internal_project_list() const;
  ::PicachvMessages::GetDataInMemory_ProjectList* _internal_mutable_project_list();
  public:
  void unsafe_arena_set_allocated_project_list(
      ::PicachvMessages::GetDataInMemory_ProjectList* project_list);
  ::PicachvMessages::GetDataInMemory_ProjectList* unsafe_arena_release_project_list();

  // @@protoc_insertion_point(class_scope:PicachvMessages.GetDataInMemory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr df_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pred_;
    ::PicachvMessages::GetDataInMemory_ProjectList* project_list_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class GetDataArgument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PicachvMessages.GetDataArgument) */ {
 public:
  inline GetDataArgument() : GetDataArgument(nullptr) {}
  ~GetDataArgument() override;
  explicit PROTOBUF_CONSTEXPR GetDataArgument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataArgument(const GetDataArgument& from);
  GetDataArgument(GetDataArgument&& from) noexcept
    : GetDataArgument() {
    *this = ::std::move(from);
  }

  inline GetDataArgument& operator=(const GetDataArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataArgument& operator=(GetDataArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataArgument& default_instance() {
    return *internal_default_instance();
  }
  enum DataSourceCase {
    kFromFile = 1,
    kInMemory = 2,
    DATA_SOURCE_NOT_SET = 0,
  };

  static inline const GetDataArgument* internal_default_instance() {
    return reinterpret_cast<const GetDataArgument*>(
               &_GetDataArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetDataArgument& a, GetDataArgument& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataArgument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataArgument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataArgument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataArgument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataArgument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataArgument& from) {
    GetDataArgument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataArgument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PicachvMessages.GetDataArgument";
  }
  protected:
  explicit GetDataArgument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFileFieldNumber = 1,
    kInMemoryFieldNumber = 2,
  };
  // .PicachvMessages.GetDataFromFileArgument from_file = 1;
  bool has_from_file() const;
  private:
  bool _internal_has_from_file() const;
  public:
  void clear_from_file();
  const ::PicachvMessages::GetDataFromFileArgument& from_file() const;
  PROTOBUF_NODISCARD ::PicachvMessages::GetDataFromFileArgument* release_from_file();
  ::PicachvMessages::GetDataFromFileArgument* mutable_from_file();
  void set_allocated_from_file(::PicachvMessages::GetDataFromFileArgument* from_file);
  private:
  const ::PicachvMessages::GetDataFromFileArgument& _internal_from_file() const;
  ::PicachvMessages::GetDataFromFileArgument* _internal_mutable_from_file();
  public:
  void unsafe_arena_set_allocated_from_file(
      ::PicachvMessages::GetDataFromFileArgument* from_file);
  ::PicachvMessages::GetDataFromFileArgument* unsafe_arena_release_from_file();

  // .PicachvMessages.GetDataInMemory in_memory = 2;
  bool has_in_memory() const;
  private:
  bool _internal_has_in_memory() const;
  public:
  void clear_in_memory();
  const ::PicachvMessages::GetDataInMemory& in_memory() const;
  PROTOBUF_NODISCARD ::PicachvMessages::GetDataInMemory* release_in_memory();
  ::PicachvMessages::GetDataInMemory* mutable_in_memory();
  void set_allocated_in_memory(::PicachvMessages::GetDataInMemory* in_memory);
  private:
  const ::PicachvMessages::GetDataInMemory& _internal_in_memory() const;
  ::PicachvMessages::GetDataInMemory* _internal_mutable_in_memory();
  public:
  void unsafe_arena_set_allocated_in_memory(
      ::PicachvMessages::GetDataInMemory* in_memory);
  ::PicachvMessages::GetDataInMemory* unsafe_arena_release_in_memory();

  void clear_data_source();
  DataSourceCase data_source_case() const;
  // @@protoc_insertion_point(class_scope:PicachvMessages.GetDataArgument)
 private:
  class _Internal;
  void set_has_from_file();
  void set_has_in_memory();

  inline bool has_data_source() const;
  inline void clear_has_data_source();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataSourceUnion {
      constexpr DataSourceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PicachvMessages::GetDataFromFileArgument* from_file_;
      ::PicachvMessages::GetDataInMemory* in_memory_;
    } data_source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class SelectArgument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PicachvMessages.SelectArgument) */ {
 public:
  inline SelectArgument() : SelectArgument(nullptr) {}
  ~SelectArgument() override;
  explicit PROTOBUF_CONSTEXPR SelectArgument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectArgument(const SelectArgument& from);
  SelectArgument(SelectArgument&& from) noexcept
    : SelectArgument() {
    *this = ::std::move(from);
  }

  inline SelectArgument& operator=(const SelectArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectArgument& operator=(SelectArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectArgument* internal_default_instance() {
    return reinterpret_cast<const SelectArgument*>(
               &_SelectArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SelectArgument& a, SelectArgument& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectArgument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectArgument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectArgument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectArgument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectArgument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectArgument& from) {
    SelectArgument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectArgument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PicachvMessages.SelectArgument";
  }
  protected:
  explicit SelectArgument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPredUuidFieldNumber = 1,
  };
  // bytes pred_uuid = 1;
  void clear_pred_uuid();
  const std::string& pred_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pred_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pred_uuid();
  PROTOBUF_NODISCARD std::string* release_pred_uuid();
  void set_allocated_pred_uuid(std::string* pred_uuid);
  private:
  const std::string& _internal_pred_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pred_uuid(const std::string& value);
  std::string* _internal_mutable_pred_uuid();
  public:

  // @@protoc_insertion_point(class_scope:PicachvMessages.SelectArgument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pred_uuid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class ProjectionArgument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PicachvMessages.ProjectionArgument) */ {
 public:
  inline ProjectionArgument() : ProjectionArgument(nullptr) {}
  ~ProjectionArgument() override;
  explicit PROTOBUF_CONSTEXPR ProjectionArgument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectionArgument(const ProjectionArgument& from);
  ProjectionArgument(ProjectionArgument&& from) noexcept
    : ProjectionArgument() {
    *this = ::std::move(from);
  }

  inline ProjectionArgument& operator=(const ProjectionArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectionArgument& operator=(ProjectionArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectionArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectionArgument* internal_default_instance() {
    return reinterpret_cast<const ProjectionArgument*>(
               &_ProjectionArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProjectionArgument& a, ProjectionArgument& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectionArgument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectionArgument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectionArgument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectionArgument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectionArgument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProjectionArgument& from) {
    ProjectionArgument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectionArgument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PicachvMessages.ProjectionArgument";
  }
  protected:
  explicit ProjectionArgument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpressionsFieldNumber = 1,
  };
  // repeated bytes expressions = 1;
  int expressions_size() const;
  private:
  int _internal_expressions_size() const;
  public:
  void clear_expressions();
  const std::string& expressions(int index) const;
  std::string* mutable_expressions(int index);
  void set_expressions(int index, const std::string& value);
  void set_expressions(int index, std::string&& value);
  void set_expressions(int index, const char* value);
  void set_expressions(int index, const void* value, size_t size);
  std::string* add_expressions();
  void add_expressions(const std::string& value);
  void add_expressions(std::string&& value);
  void add_expressions(const char* value);
  void add_expressions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& expressions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_expressions();
  private:
  const std::string& _internal_expressions(int index) const;
  std::string* _internal_add_expressions();
  public:

  // @@protoc_insertion_point(class_scope:PicachvMessages.ProjectionArgument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> expressions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class TransformArgument final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PicachvMessages.TransformArgument) */ {
 public:
  inline TransformArgument() : TransformArgument(nullptr) {}
  explicit PROTOBUF_CONSTEXPR TransformArgument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransformArgument(const TransformArgument& from);
  TransformArgument(TransformArgument&& from) noexcept
    : TransformArgument() {
    *this = ::std::move(from);
  }

  inline TransformArgument& operator=(const TransformArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformArgument& operator=(TransformArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransformArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransformArgument* internal_default_instance() {
    return reinterpret_cast<const TransformArgument*>(
               &_TransformArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TransformArgument& a, TransformArgument& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformArgument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransformArgument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransformArgument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransformArgument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TransformArgument& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TransformArgument& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PicachvMessages.TransformArgument";
  }
  protected:
  explicit TransformArgument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PicachvMessages.TransformArgument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class HstackArgument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PicachvMessages.HstackArgument) */ {
 public:
  inline HstackArgument() : HstackArgument(nullptr) {}
  ~HstackArgument() override;
  explicit PROTOBUF_CONSTEXPR HstackArgument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HstackArgument(const HstackArgument& from);
  HstackArgument(HstackArgument&& from) noexcept
    : HstackArgument() {
    *this = ::std::move(from);
  }

  inline HstackArgument& operator=(const HstackArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline HstackArgument& operator=(HstackArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HstackArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const HstackArgument* internal_default_instance() {
    return reinterpret_cast<const HstackArgument*>(
               &_HstackArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HstackArgument& a, HstackArgument& b) {
    a.Swap(&b);
  }
  inline void Swap(HstackArgument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HstackArgument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HstackArgument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HstackArgument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HstackArgument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HstackArgument& from) {
    HstackArgument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HstackArgument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PicachvMessages.HstackArgument";
  }
  protected:
  explicit HstackArgument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCseFieldNumber = 1,
    kExpressionsFieldNumber = 2,
  };
  // repeated bytes cse = 1;
  int cse_size() const;
  private:
  int _internal_cse_size() const;
  public:
  void clear_cse();
  const std::string& cse(int index) const;
  std::string* mutable_cse(int index);
  void set_cse(int index, const std::string& value);
  void set_cse(int index, std::string&& value);
  void set_cse(int index, const char* value);
  void set_cse(int index, const void* value, size_t size);
  std::string* add_cse();
  void add_cse(const std::string& value);
  void add_cse(std::string&& value);
  void add_cse(const char* value);
  void add_cse(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cse() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cse();
  private:
  const std::string& _internal_cse(int index) const;
  std::string* _internal_add_cse();
  public:

  // repeated bytes expressions = 2;
  int expressions_size() const;
  private:
  int _internal_expressions_size() const;
  public:
  void clear_expressions();
  const std::string& expressions(int index) const;
  std::string* mutable_expressions(int index);
  void set_expressions(int index, const std::string& value);
  void set_expressions(int index, std::string&& value);
  void set_expressions(int index, const char* value);
  void set_expressions(int index, const void* value, size_t size);
  std::string* add_expressions();
  void add_expressions(const std::string& value);
  void add_expressions(std::string&& value);
  void add_expressions(const char* value);
  void add_expressions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& expressions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_expressions();
  private:
  const std::string& _internal_expressions(int index) const;
  std::string* _internal_add_expressions();
  public:

  // @@protoc_insertion_point(class_scope:PicachvMessages.HstackArgument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cse_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> expressions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class AggregateArgument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PicachvMessages.AggregateArgument) */ {
 public:
  inline AggregateArgument() : AggregateArgument(nullptr) {}
  ~AggregateArgument() override;
  explicit PROTOBUF_CONSTEXPR AggregateArgument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregateArgument(const AggregateArgument& from);
  AggregateArgument(AggregateArgument&& from) noexcept
    : AggregateArgument() {
    *this = ::std::move(from);
  }

  inline AggregateArgument& operator=(const AggregateArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateArgument& operator=(AggregateArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateArgument* internal_default_instance() {
    return reinterpret_cast<const AggregateArgument*>(
               &_AggregateArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AggregateArgument& a, AggregateArgument& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateArgument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateArgument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateArgument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateArgument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggregateArgument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AggregateArgument& from) {
    AggregateArgument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateArgument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PicachvMessages.AggregateArgument";
  }
  protected:
  explicit AggregateArgument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
    kAggsUuidFieldNumber = 2,
    kOutputSchemaFieldNumber = 5,
    kGroupByProxyFieldNumber = 4,
    kMaintainOrderFieldNumber = 3,
  };
  // repeated bytes keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // repeated bytes aggs_uuid = 2;
  int aggs_uuid_size() const;
  private:
  int _internal_aggs_uuid_size() const;
  public:
  void clear_aggs_uuid();
  const std::string& aggs_uuid(int index) const;
  std::string* mutable_aggs_uuid(int index);
  void set_aggs_uuid(int index, const std::string& value);
  void set_aggs_uuid(int index, std::string&& value);
  void set_aggs_uuid(int index, const char* value);
  void set_aggs_uuid(int index, const void* value, size_t size);
  std::string* add_aggs_uuid();
  void add_aggs_uuid(const std::string& value);
  void add_aggs_uuid(std::string&& value);
  void add_aggs_uuid(const char* value);
  void add_aggs_uuid(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& aggs_uuid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_aggs_uuid();
  private:
  const std::string& _internal_aggs_uuid(int index) const;
  std::string* _internal_add_aggs_uuid();
  public:

  // repeated string output_schema = 5;
  int output_schema_size() const;
  private:
  int _internal_output_schema_size() const;
  public:
  void clear_output_schema();
  const std::string& output_schema(int index) const;
  std::string* mutable_output_schema(int index);
  void set_output_schema(int index, const std::string& value);
  void set_output_schema(int index, std::string&& value);
  void set_output_schema(int index, const char* value);
  void set_output_schema(int index, const char* value, size_t size);
  std::string* add_output_schema();
  void add_output_schema(const std::string& value);
  void add_output_schema(std::string&& value);
  void add_output_schema(const char* value);
  void add_output_schema(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& output_schema() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_output_schema();
  private:
  const std::string& _internal_output_schema(int index) const;
  std::string* _internal_add_output_schema();
  public:

  // .PicachvMessages.GroupByProxy group_by_proxy = 4;
  bool has_group_by_proxy() const;
  private:
  bool _internal_has_group_by_proxy() const;
  public:
  void clear_group_by_proxy();
  const ::PicachvMessages::GroupByProxy& group_by_proxy() const;
  PROTOBUF_NODISCARD ::PicachvMessages::GroupByProxy* release_group_by_proxy();
  ::PicachvMessages::GroupByProxy* mutable_group_by_proxy();
  void set_allocated_group_by_proxy(::PicachvMessages::GroupByProxy* group_by_proxy);
  private:
  const ::PicachvMessages::GroupByProxy& _internal_group_by_proxy() const;
  ::PicachvMessages::GroupByProxy* _internal_mutable_group_by_proxy();
  public:
  void unsafe_arena_set_allocated_group_by_proxy(
      ::PicachvMessages::GroupByProxy* group_by_proxy);
  ::PicachvMessages::GroupByProxy* unsafe_arena_release_group_by_proxy();

  // bool maintain_order = 3;
  void clear_maintain_order();
  bool maintain_order() const;
  void set_maintain_order(bool value);
  private:
  bool _internal_maintain_order() const;
  void _internal_set_maintain_order(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PicachvMessages.AggregateArgument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> aggs_uuid_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> output_schema_;
    ::PicachvMessages::GroupByProxy* group_by_proxy_;
    bool maintain_order_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class PlanArgument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PicachvMessages.PlanArgument) */ {
 public:
  inline PlanArgument() : PlanArgument(nullptr) {}
  ~PlanArgument() override;
  explicit PROTOBUF_CONSTEXPR PlanArgument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanArgument(const PlanArgument& from);
  PlanArgument(PlanArgument&& from) noexcept
    : PlanArgument() {
    *this = ::std::move(from);
  }

  inline PlanArgument& operator=(const PlanArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanArgument& operator=(PlanArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanArgument& default_instance() {
    return *internal_default_instance();
  }
  enum ArgumentCase {
    kSelect = 1,
    kProjection = 2,
    kAggregate = 3,
    kGetData = 4,
    kTransform = 5,
    kHstack = 6,
    ARGUMENT_NOT_SET = 0,
  };

  static inline const PlanArgument* internal_default_instance() {
    return reinterpret_cast<const PlanArgument*>(
               &_PlanArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PlanArgument& a, PlanArgument& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanArgument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanArgument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanArgument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanArgument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanArgument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlanArgument& from) {
    PlanArgument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanArgument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PicachvMessages.PlanArgument";
  }
  protected:
  explicit PlanArgument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransformInfoFieldNumber = 7,
    kSelectFieldNumber = 1,
    kProjectionFieldNumber = 2,
    kAggregateFieldNumber = 3,
    kGetDataFieldNumber = 4,
    kTransformFieldNumber = 5,
    kHstackFieldNumber = 6,
  };
  // .PicachvMessages.TransformInfo transform_info = 7;
  bool has_transform_info() const;
  private:
  bool _internal_has_transform_info() const;
  public:
  void clear_transform_info();
  const ::PicachvMessages::TransformInfo& transform_info() const;
  PROTOBUF_NODISCARD ::PicachvMessages::TransformInfo* release_transform_info();
  ::PicachvMessages::TransformInfo* mutable_transform_info();
  void set_allocated_transform_info(::PicachvMessages::TransformInfo* transform_info);
  private:
  const ::PicachvMessages::TransformInfo& _internal_transform_info() const;
  ::PicachvMessages::TransformInfo* _internal_mutable_transform_info();
  public:
  void unsafe_arena_set_allocated_transform_info(
      ::PicachvMessages::TransformInfo* transform_info);
  ::PicachvMessages::TransformInfo* unsafe_arena_release_transform_info();

  // .PicachvMessages.SelectArgument select = 1;
  bool has_select() const;
  private:
  bool _internal_has_select() const;
  public:
  void clear_select();
  const ::PicachvMessages::SelectArgument& select() const;
  PROTOBUF_NODISCARD ::PicachvMessages::SelectArgument* release_select();
  ::PicachvMessages::SelectArgument* mutable_select();
  void set_allocated_select(::PicachvMessages::SelectArgument* select);
  private:
  const ::PicachvMessages::SelectArgument& _internal_select() const;
  ::PicachvMessages::SelectArgument* _internal_mutable_select();
  public:
  void unsafe_arena_set_allocated_select(
      ::PicachvMessages::SelectArgument* select);
  ::PicachvMessages::SelectArgument* unsafe_arena_release_select();

  // .PicachvMessages.ProjectionArgument projection = 2;
  bool has_projection() const;
  private:
  bool _internal_has_projection() const;
  public:
  void clear_projection();
  const ::PicachvMessages::ProjectionArgument& projection() const;
  PROTOBUF_NODISCARD ::PicachvMessages::ProjectionArgument* release_projection();
  ::PicachvMessages::ProjectionArgument* mutable_projection();
  void set_allocated_projection(::PicachvMessages::ProjectionArgument* projection);
  private:
  const ::PicachvMessages::ProjectionArgument& _internal_projection() const;
  ::PicachvMessages::ProjectionArgument* _internal_mutable_projection();
  public:
  void unsafe_arena_set_allocated_projection(
      ::PicachvMessages::ProjectionArgument* projection);
  ::PicachvMessages::ProjectionArgument* unsafe_arena_release_projection();

  // .PicachvMessages.AggregateArgument aggregate = 3;
  bool has_aggregate() const;
  private:
  bool _internal_has_aggregate() const;
  public:
  void clear_aggregate();
  const ::PicachvMessages::AggregateArgument& aggregate() const;
  PROTOBUF_NODISCARD ::PicachvMessages::AggregateArgument* release_aggregate();
  ::PicachvMessages::AggregateArgument* mutable_aggregate();
  void set_allocated_aggregate(::PicachvMessages::AggregateArgument* aggregate);
  private:
  const ::PicachvMessages::AggregateArgument& _internal_aggregate() const;
  ::PicachvMessages::AggregateArgument* _internal_mutable_aggregate();
  public:
  void unsafe_arena_set_allocated_aggregate(
      ::PicachvMessages::AggregateArgument* aggregate);
  ::PicachvMessages::AggregateArgument* unsafe_arena_release_aggregate();

  // .PicachvMessages.GetDataArgument get_data = 4;
  bool has_get_data() const;
  private:
  bool _internal_has_get_data() const;
  public:
  void clear_get_data();
  const ::PicachvMessages::GetDataArgument& get_data() const;
  PROTOBUF_NODISCARD ::PicachvMessages::GetDataArgument* release_get_data();
  ::PicachvMessages::GetDataArgument* mutable_get_data();
  void set_allocated_get_data(::PicachvMessages::GetDataArgument* get_data);
  private:
  const ::PicachvMessages::GetDataArgument& _internal_get_data() const;
  ::PicachvMessages::GetDataArgument* _internal_mutable_get_data();
  public:
  void unsafe_arena_set_allocated_get_data(
      ::PicachvMessages::GetDataArgument* get_data);
  ::PicachvMessages::GetDataArgument* unsafe_arena_release_get_data();

  // .PicachvMessages.TransformArgument transform = 5;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::PicachvMessages::TransformArgument& transform() const;
  PROTOBUF_NODISCARD ::PicachvMessages::TransformArgument* release_transform();
  ::PicachvMessages::TransformArgument* mutable_transform();
  void set_allocated_transform(::PicachvMessages::TransformArgument* transform);
  private:
  const ::PicachvMessages::TransformArgument& _internal_transform() const;
  ::PicachvMessages::TransformArgument* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::PicachvMessages::TransformArgument* transform);
  ::PicachvMessages::TransformArgument* unsafe_arena_release_transform();

  // .PicachvMessages.HstackArgument hstack = 6;
  bool has_hstack() const;
  private:
  bool _internal_has_hstack() const;
  public:
  void clear_hstack();
  const ::PicachvMessages::HstackArgument& hstack() const;
  PROTOBUF_NODISCARD ::PicachvMessages::HstackArgument* release_hstack();
  ::PicachvMessages::HstackArgument* mutable_hstack();
  void set_allocated_hstack(::PicachvMessages::HstackArgument* hstack);
  private:
  const ::PicachvMessages::HstackArgument& _internal_hstack() const;
  ::PicachvMessages::HstackArgument* _internal_mutable_hstack();
  public:
  void unsafe_arena_set_allocated_hstack(
      ::PicachvMessages::HstackArgument* hstack);
  ::PicachvMessages::HstackArgument* unsafe_arena_release_hstack();

  void clear_argument();
  ArgumentCase argument_case() const;
  // @@protoc_insertion_point(class_scope:PicachvMessages.PlanArgument)
 private:
  class _Internal;
  void set_has_select();
  void set_has_projection();
  void set_has_aggregate();
  void set_has_get_data();
  void set_has_transform();
  void set_has_hstack();

  inline bool has_argument() const;
  inline void clear_has_argument();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PicachvMessages::TransformInfo* transform_info_;
    union ArgumentUnion {
      constexpr ArgumentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PicachvMessages::SelectArgument* select_;
      ::PicachvMessages::ProjectionArgument* projection_;
      ::PicachvMessages::AggregateArgument* aggregate_;
      ::PicachvMessages::GetDataArgument* get_data_;
      ::PicachvMessages::TransformArgument* transform_;
      ::PicachvMessages::HstackArgument* hstack_;
    } argument_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetDataFromFileArgument

// string path = 1;
inline void GetDataFromFileArgument::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& GetDataFromFileArgument::path() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataFromFileArgument.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDataFromFileArgument::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataFromFileArgument.path)
}
inline std::string* GetDataFromFileArgument::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataFromFileArgument.path)
  return _s;
}
inline const std::string& GetDataFromFileArgument::_internal_path() const {
  return _impl_.path_.Get();
}
inline void GetDataFromFileArgument::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDataFromFileArgument::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDataFromFileArgument::release_path() {
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataFromFileArgument.path)
  return _impl_.path_.Release();
}
inline void GetDataFromFileArgument::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.GetDataFromFileArgument.path)
}

// .PicachvMessages.FileType file_type = 2;
inline void GetDataFromFileArgument::clear_file_type() {
  _impl_.file_type_ = 0;
}
inline ::PicachvMessages::FileType GetDataFromFileArgument::_internal_file_type() const {
  return static_cast< ::PicachvMessages::FileType >(_impl_.file_type_);
}
inline ::PicachvMessages::FileType GetDataFromFileArgument::file_type() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataFromFileArgument.file_type)
  return _internal_file_type();
}
inline void GetDataFromFileArgument::_internal_set_file_type(::PicachvMessages::FileType value) {
  
  _impl_.file_type_ = value;
}
inline void GetDataFromFileArgument::set_file_type(::PicachvMessages::FileType value) {
  _internal_set_file_type(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataFromFileArgument.file_type)
}

// bytes df_uuid = 3;
inline void GetDataFromFileArgument::clear_df_uuid() {
  _impl_.df_uuid_.ClearToEmpty();
}
inline const std::string& GetDataFromFileArgument::df_uuid() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataFromFileArgument.df_uuid)
  return _internal_df_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDataFromFileArgument::set_df_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.df_uuid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataFromFileArgument.df_uuid)
}
inline std::string* GetDataFromFileArgument::mutable_df_uuid() {
  std::string* _s = _internal_mutable_df_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataFromFileArgument.df_uuid)
  return _s;
}
inline const std::string& GetDataFromFileArgument::_internal_df_uuid() const {
  return _impl_.df_uuid_.Get();
}
inline void GetDataFromFileArgument::_internal_set_df_uuid(const std::string& value) {
  
  _impl_.df_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDataFromFileArgument::_internal_mutable_df_uuid() {
  
  return _impl_.df_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDataFromFileArgument::release_df_uuid() {
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataFromFileArgument.df_uuid)
  return _impl_.df_uuid_.Release();
}
inline void GetDataFromFileArgument::set_allocated_df_uuid(std::string* df_uuid) {
  if (df_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.df_uuid_.SetAllocated(df_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.df_uuid_.IsDefault()) {
    _impl_.df_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.GetDataFromFileArgument.df_uuid)
}

// -------------------------------------------------------------------

// GetDataInMemory_ProjectList

// repeated uint64 project_list = 1;
inline int GetDataInMemory_ProjectList::_internal_project_list_size() const {
  return _impl_.project_list_.size();
}
inline int GetDataInMemory_ProjectList::project_list_size() const {
  return _internal_project_list_size();
}
inline void GetDataInMemory_ProjectList::clear_project_list() {
  _impl_.project_list_.Clear();
}
inline uint64_t GetDataInMemory_ProjectList::_internal_project_list(int index) const {
  return _impl_.project_list_.Get(index);
}
inline uint64_t GetDataInMemory_ProjectList::project_list(int index) const {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataInMemory.ProjectList.project_list)
  return _internal_project_list(index);
}
inline void GetDataInMemory_ProjectList::set_project_list(int index, uint64_t value) {
  _impl_.project_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataInMemory.ProjectList.project_list)
}
inline void GetDataInMemory_ProjectList::_internal_add_project_list(uint64_t value) {
  _impl_.project_list_.Add(value);
}
inline void GetDataInMemory_ProjectList::add_project_list(uint64_t value) {
  _internal_add_project_list(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.GetDataInMemory.ProjectList.project_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetDataInMemory_ProjectList::_internal_project_list() const {
  return _impl_.project_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetDataInMemory_ProjectList::project_list() const {
  // @@protoc_insertion_point(field_list:PicachvMessages.GetDataInMemory.ProjectList.project_list)
  return _internal_project_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetDataInMemory_ProjectList::_internal_mutable_project_list() {
  return &_impl_.project_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetDataInMemory_ProjectList::mutable_project_list() {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.GetDataInMemory.ProjectList.project_list)
  return _internal_mutable_project_list();
}

// -------------------------------------------------------------------

// GetDataInMemory

// bytes df_uuid = 1;
inline void GetDataInMemory::clear_df_uuid() {
  _impl_.df_uuid_.ClearToEmpty();
}
inline const std::string& GetDataInMemory::df_uuid() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataInMemory.df_uuid)
  return _internal_df_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDataInMemory::set_df_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.df_uuid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataInMemory.df_uuid)
}
inline std::string* GetDataInMemory::mutable_df_uuid() {
  std::string* _s = _internal_mutable_df_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataInMemory.df_uuid)
  return _s;
}
inline const std::string& GetDataInMemory::_internal_df_uuid() const {
  return _impl_.df_uuid_.Get();
}
inline void GetDataInMemory::_internal_set_df_uuid(const std::string& value) {
  
  _impl_.df_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDataInMemory::_internal_mutable_df_uuid() {
  
  return _impl_.df_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDataInMemory::release_df_uuid() {
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataInMemory.df_uuid)
  return _impl_.df_uuid_.Release();
}
inline void GetDataInMemory::set_allocated_df_uuid(std::string* df_uuid) {
  if (df_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.df_uuid_.SetAllocated(df_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.df_uuid_.IsDefault()) {
    _impl_.df_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.GetDataInMemory.df_uuid)
}

// optional bytes pred = 2;
inline bool GetDataInMemory::_internal_has_pred() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetDataInMemory::has_pred() const {
  return _internal_has_pred();
}
inline void GetDataInMemory::clear_pred() {
  _impl_.pred_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetDataInMemory::pred() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataInMemory.pred)
  return _internal_pred();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDataInMemory::set_pred(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pred_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataInMemory.pred)
}
inline std::string* GetDataInMemory::mutable_pred() {
  std::string* _s = _internal_mutable_pred();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataInMemory.pred)
  return _s;
}
inline const std::string& GetDataInMemory::_internal_pred() const {
  return _impl_.pred_.Get();
}
inline void GetDataInMemory::_internal_set_pred(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pred_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDataInMemory::_internal_mutable_pred() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pred_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDataInMemory::release_pred() {
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataInMemory.pred)
  if (!_internal_has_pred()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pred_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pred_.IsDefault()) {
    _impl_.pred_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetDataInMemory::set_allocated_pred(std::string* pred) {
  if (pred != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pred_.SetAllocated(pred, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pred_.IsDefault()) {
    _impl_.pred_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.GetDataInMemory.pred)
}

// optional .PicachvMessages.GetDataInMemory.ProjectList project_list = 3;
inline bool GetDataInMemory::_internal_has_project_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.project_list_ != nullptr);
  return value;
}
inline bool GetDataInMemory::has_project_list() const {
  return _internal_has_project_list();
}
inline void GetDataInMemory::clear_project_list() {
  if (_impl_.project_list_ != nullptr) _impl_.project_list_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::PicachvMessages::GetDataInMemory_ProjectList& GetDataInMemory::_internal_project_list() const {
  const ::PicachvMessages::GetDataInMemory_ProjectList* p = _impl_.project_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::PicachvMessages::GetDataInMemory_ProjectList&>(
      ::PicachvMessages::_GetDataInMemory_ProjectList_default_instance_);
}
inline const ::PicachvMessages::GetDataInMemory_ProjectList& GetDataInMemory::project_list() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataInMemory.project_list)
  return _internal_project_list();
}
inline void GetDataInMemory::unsafe_arena_set_allocated_project_list(
    ::PicachvMessages::GetDataInMemory_ProjectList* project_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.project_list_);
  }
  _impl_.project_list_ = project_list;
  if (project_list) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.GetDataInMemory.project_list)
}
inline ::PicachvMessages::GetDataInMemory_ProjectList* GetDataInMemory::release_project_list() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PicachvMessages::GetDataInMemory_ProjectList* temp = _impl_.project_list_;
  _impl_.project_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PicachvMessages::GetDataInMemory_ProjectList* GetDataInMemory::unsafe_arena_release_project_list() {
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataInMemory.project_list)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PicachvMessages::GetDataInMemory_ProjectList* temp = _impl_.project_list_;
  _impl_.project_list_ = nullptr;
  return temp;
}
inline ::PicachvMessages::GetDataInMemory_ProjectList* GetDataInMemory::_internal_mutable_project_list() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.project_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::PicachvMessages::GetDataInMemory_ProjectList>(GetArenaForAllocation());
    _impl_.project_list_ = p;
  }
  return _impl_.project_list_;
}
inline ::PicachvMessages::GetDataInMemory_ProjectList* GetDataInMemory::mutable_project_list() {
  ::PicachvMessages::GetDataInMemory_ProjectList* _msg = _internal_mutable_project_list();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataInMemory.project_list)
  return _msg;
}
inline void GetDataInMemory::set_allocated_project_list(::PicachvMessages::GetDataInMemory_ProjectList* project_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.project_list_;
  }
  if (project_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(project_list);
    if (message_arena != submessage_arena) {
      project_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, project_list, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.project_list_ = project_list;
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.GetDataInMemory.project_list)
}

// -------------------------------------------------------------------

// GetDataArgument

// .PicachvMessages.GetDataFromFileArgument from_file = 1;
inline bool GetDataArgument::_internal_has_from_file() const {
  return data_source_case() == kFromFile;
}
inline bool GetDataArgument::has_from_file() const {
  return _internal_has_from_file();
}
inline void GetDataArgument::set_has_from_file() {
  _impl_._oneof_case_[0] = kFromFile;
}
inline void GetDataArgument::clear_from_file() {
  if (_internal_has_from_file()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_source_.from_file_;
    }
    clear_has_data_source();
  }
}
inline ::PicachvMessages::GetDataFromFileArgument* GetDataArgument::release_from_file() {
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataArgument.from_file)
  if (_internal_has_from_file()) {
    clear_has_data_source();
    ::PicachvMessages::GetDataFromFileArgument* temp = _impl_.data_source_.from_file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_source_.from_file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::GetDataFromFileArgument& GetDataArgument::_internal_from_file() const {
  return _internal_has_from_file()
      ? *_impl_.data_source_.from_file_
      : reinterpret_cast< ::PicachvMessages::GetDataFromFileArgument&>(::PicachvMessages::_GetDataFromFileArgument_default_instance_);
}
inline const ::PicachvMessages::GetDataFromFileArgument& GetDataArgument::from_file() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataArgument.from_file)
  return _internal_from_file();
}
inline ::PicachvMessages::GetDataFromFileArgument* GetDataArgument::unsafe_arena_release_from_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.GetDataArgument.from_file)
  if (_internal_has_from_file()) {
    clear_has_data_source();
    ::PicachvMessages::GetDataFromFileArgument* temp = _impl_.data_source_.from_file_;
    _impl_.data_source_.from_file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetDataArgument::unsafe_arena_set_allocated_from_file(::PicachvMessages::GetDataFromFileArgument* from_file) {
  clear_data_source();
  if (from_file) {
    set_has_from_file();
    _impl_.data_source_.from_file_ = from_file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.GetDataArgument.from_file)
}
inline ::PicachvMessages::GetDataFromFileArgument* GetDataArgument::_internal_mutable_from_file() {
  if (!_internal_has_from_file()) {
    clear_data_source();
    set_has_from_file();
    _impl_.data_source_.from_file_ = CreateMaybeMessage< ::PicachvMessages::GetDataFromFileArgument >(GetArenaForAllocation());
  }
  return _impl_.data_source_.from_file_;
}
inline ::PicachvMessages::GetDataFromFileArgument* GetDataArgument::mutable_from_file() {
  ::PicachvMessages::GetDataFromFileArgument* _msg = _internal_mutable_from_file();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataArgument.from_file)
  return _msg;
}

// .PicachvMessages.GetDataInMemory in_memory = 2;
inline bool GetDataArgument::_internal_has_in_memory() const {
  return data_source_case() == kInMemory;
}
inline bool GetDataArgument::has_in_memory() const {
  return _internal_has_in_memory();
}
inline void GetDataArgument::set_has_in_memory() {
  _impl_._oneof_case_[0] = kInMemory;
}
inline void GetDataArgument::clear_in_memory() {
  if (_internal_has_in_memory()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_source_.in_memory_;
    }
    clear_has_data_source();
  }
}
inline ::PicachvMessages::GetDataInMemory* GetDataArgument::release_in_memory() {
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataArgument.in_memory)
  if (_internal_has_in_memory()) {
    clear_has_data_source();
    ::PicachvMessages::GetDataInMemory* temp = _impl_.data_source_.in_memory_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_source_.in_memory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::GetDataInMemory& GetDataArgument::_internal_in_memory() const {
  return _internal_has_in_memory()
      ? *_impl_.data_source_.in_memory_
      : reinterpret_cast< ::PicachvMessages::GetDataInMemory&>(::PicachvMessages::_GetDataInMemory_default_instance_);
}
inline const ::PicachvMessages::GetDataInMemory& GetDataArgument::in_memory() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataArgument.in_memory)
  return _internal_in_memory();
}
inline ::PicachvMessages::GetDataInMemory* GetDataArgument::unsafe_arena_release_in_memory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.GetDataArgument.in_memory)
  if (_internal_has_in_memory()) {
    clear_has_data_source();
    ::PicachvMessages::GetDataInMemory* temp = _impl_.data_source_.in_memory_;
    _impl_.data_source_.in_memory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetDataArgument::unsafe_arena_set_allocated_in_memory(::PicachvMessages::GetDataInMemory* in_memory) {
  clear_data_source();
  if (in_memory) {
    set_has_in_memory();
    _impl_.data_source_.in_memory_ = in_memory;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.GetDataArgument.in_memory)
}
inline ::PicachvMessages::GetDataInMemory* GetDataArgument::_internal_mutable_in_memory() {
  if (!_internal_has_in_memory()) {
    clear_data_source();
    set_has_in_memory();
    _impl_.data_source_.in_memory_ = CreateMaybeMessage< ::PicachvMessages::GetDataInMemory >(GetArenaForAllocation());
  }
  return _impl_.data_source_.in_memory_;
}
inline ::PicachvMessages::GetDataInMemory* GetDataArgument::mutable_in_memory() {
  ::PicachvMessages::GetDataInMemory* _msg = _internal_mutable_in_memory();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataArgument.in_memory)
  return _msg;
}

inline bool GetDataArgument::has_data_source() const {
  return data_source_case() != DATA_SOURCE_NOT_SET;
}
inline void GetDataArgument::clear_has_data_source() {
  _impl_._oneof_case_[0] = DATA_SOURCE_NOT_SET;
}
inline GetDataArgument::DataSourceCase GetDataArgument::data_source_case() const {
  return GetDataArgument::DataSourceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SelectArgument

// bytes pred_uuid = 1;
inline void SelectArgument::clear_pred_uuid() {
  _impl_.pred_uuid_.ClearToEmpty();
}
inline const std::string& SelectArgument::pred_uuid() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.SelectArgument.pred_uuid)
  return _internal_pred_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectArgument::set_pred_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pred_uuid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PicachvMessages.SelectArgument.pred_uuid)
}
inline std::string* SelectArgument::mutable_pred_uuid() {
  std::string* _s = _internal_mutable_pred_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.SelectArgument.pred_uuid)
  return _s;
}
inline const std::string& SelectArgument::_internal_pred_uuid() const {
  return _impl_.pred_uuid_.Get();
}
inline void SelectArgument::_internal_set_pred_uuid(const std::string& value) {
  
  _impl_.pred_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectArgument::_internal_mutable_pred_uuid() {
  
  return _impl_.pred_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectArgument::release_pred_uuid() {
  // @@protoc_insertion_point(field_release:PicachvMessages.SelectArgument.pred_uuid)
  return _impl_.pred_uuid_.Release();
}
inline void SelectArgument::set_allocated_pred_uuid(std::string* pred_uuid) {
  if (pred_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.pred_uuid_.SetAllocated(pred_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pred_uuid_.IsDefault()) {
    _impl_.pred_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.SelectArgument.pred_uuid)
}

// -------------------------------------------------------------------

// ProjectionArgument

// repeated bytes expressions = 1;
inline int ProjectionArgument::_internal_expressions_size() const {
  return _impl_.expressions_.size();
}
inline int ProjectionArgument::expressions_size() const {
  return _internal_expressions_size();
}
inline void ProjectionArgument::clear_expressions() {
  _impl_.expressions_.Clear();
}
inline std::string* ProjectionArgument::add_expressions() {
  std::string* _s = _internal_add_expressions();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.ProjectionArgument.expressions)
  return _s;
}
inline const std::string& ProjectionArgument::_internal_expressions(int index) const {
  return _impl_.expressions_.Get(index);
}
inline const std::string& ProjectionArgument::expressions(int index) const {
  // @@protoc_insertion_point(field_get:PicachvMessages.ProjectionArgument.expressions)
  return _internal_expressions(index);
}
inline std::string* ProjectionArgument::mutable_expressions(int index) {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ProjectionArgument.expressions)
  return _impl_.expressions_.Mutable(index);
}
inline void ProjectionArgument::set_expressions(int index, const std::string& value) {
  _impl_.expressions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.ProjectionArgument.expressions)
}
inline void ProjectionArgument::set_expressions(int index, std::string&& value) {
  _impl_.expressions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.ProjectionArgument.expressions)
}
inline void ProjectionArgument::set_expressions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.expressions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.ProjectionArgument.expressions)
}
inline void ProjectionArgument::set_expressions(int index, const void* value, size_t size) {
  _impl_.expressions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.ProjectionArgument.expressions)
}
inline std::string* ProjectionArgument::_internal_add_expressions() {
  return _impl_.expressions_.Add();
}
inline void ProjectionArgument::add_expressions(const std::string& value) {
  _impl_.expressions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.ProjectionArgument.expressions)
}
inline void ProjectionArgument::add_expressions(std::string&& value) {
  _impl_.expressions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.ProjectionArgument.expressions)
}
inline void ProjectionArgument::add_expressions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.expressions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.ProjectionArgument.expressions)
}
inline void ProjectionArgument::add_expressions(const void* value, size_t size) {
  _impl_.expressions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.ProjectionArgument.expressions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProjectionArgument::expressions() const {
  // @@protoc_insertion_point(field_list:PicachvMessages.ProjectionArgument.expressions)
  return _impl_.expressions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProjectionArgument::mutable_expressions() {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.ProjectionArgument.expressions)
  return &_impl_.expressions_;
}

// -------------------------------------------------------------------

// TransformArgument

// -------------------------------------------------------------------

// HstackArgument

// repeated bytes cse = 1;
inline int HstackArgument::_internal_cse_size() const {
  return _impl_.cse_.size();
}
inline int HstackArgument::cse_size() const {
  return _internal_cse_size();
}
inline void HstackArgument::clear_cse() {
  _impl_.cse_.Clear();
}
inline std::string* HstackArgument::add_cse() {
  std::string* _s = _internal_add_cse();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.HstackArgument.cse)
  return _s;
}
inline const std::string& HstackArgument::_internal_cse(int index) const {
  return _impl_.cse_.Get(index);
}
inline const std::string& HstackArgument::cse(int index) const {
  // @@protoc_insertion_point(field_get:PicachvMessages.HstackArgument.cse)
  return _internal_cse(index);
}
inline std::string* HstackArgument::mutable_cse(int index) {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.HstackArgument.cse)
  return _impl_.cse_.Mutable(index);
}
inline void HstackArgument::set_cse(int index, const std::string& value) {
  _impl_.cse_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.HstackArgument.cse)
}
inline void HstackArgument::set_cse(int index, std::string&& value) {
  _impl_.cse_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.HstackArgument.cse)
}
inline void HstackArgument::set_cse(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cse_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.HstackArgument.cse)
}
inline void HstackArgument::set_cse(int index, const void* value, size_t size) {
  _impl_.cse_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.HstackArgument.cse)
}
inline std::string* HstackArgument::_internal_add_cse() {
  return _impl_.cse_.Add();
}
inline void HstackArgument::add_cse(const std::string& value) {
  _impl_.cse_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.HstackArgument.cse)
}
inline void HstackArgument::add_cse(std::string&& value) {
  _impl_.cse_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.HstackArgument.cse)
}
inline void HstackArgument::add_cse(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cse_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.HstackArgument.cse)
}
inline void HstackArgument::add_cse(const void* value, size_t size) {
  _impl_.cse_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.HstackArgument.cse)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HstackArgument::cse() const {
  // @@protoc_insertion_point(field_list:PicachvMessages.HstackArgument.cse)
  return _impl_.cse_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HstackArgument::mutable_cse() {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.HstackArgument.cse)
  return &_impl_.cse_;
}

// repeated bytes expressions = 2;
inline int HstackArgument::_internal_expressions_size() const {
  return _impl_.expressions_.size();
}
inline int HstackArgument::expressions_size() const {
  return _internal_expressions_size();
}
inline void HstackArgument::clear_expressions() {
  _impl_.expressions_.Clear();
}
inline std::string* HstackArgument::add_expressions() {
  std::string* _s = _internal_add_expressions();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.HstackArgument.expressions)
  return _s;
}
inline const std::string& HstackArgument::_internal_expressions(int index) const {
  return _impl_.expressions_.Get(index);
}
inline const std::string& HstackArgument::expressions(int index) const {
  // @@protoc_insertion_point(field_get:PicachvMessages.HstackArgument.expressions)
  return _internal_expressions(index);
}
inline std::string* HstackArgument::mutable_expressions(int index) {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.HstackArgument.expressions)
  return _impl_.expressions_.Mutable(index);
}
inline void HstackArgument::set_expressions(int index, const std::string& value) {
  _impl_.expressions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.HstackArgument.expressions)
}
inline void HstackArgument::set_expressions(int index, std::string&& value) {
  _impl_.expressions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.HstackArgument.expressions)
}
inline void HstackArgument::set_expressions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.expressions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.HstackArgument.expressions)
}
inline void HstackArgument::set_expressions(int index, const void* value, size_t size) {
  _impl_.expressions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.HstackArgument.expressions)
}
inline std::string* HstackArgument::_internal_add_expressions() {
  return _impl_.expressions_.Add();
}
inline void HstackArgument::add_expressions(const std::string& value) {
  _impl_.expressions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.HstackArgument.expressions)
}
inline void HstackArgument::add_expressions(std::string&& value) {
  _impl_.expressions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.HstackArgument.expressions)
}
inline void HstackArgument::add_expressions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.expressions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.HstackArgument.expressions)
}
inline void HstackArgument::add_expressions(const void* value, size_t size) {
  _impl_.expressions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.HstackArgument.expressions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HstackArgument::expressions() const {
  // @@protoc_insertion_point(field_list:PicachvMessages.HstackArgument.expressions)
  return _impl_.expressions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HstackArgument::mutable_expressions() {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.HstackArgument.expressions)
  return &_impl_.expressions_;
}

// -------------------------------------------------------------------

// AggregateArgument

// repeated bytes keys = 1;
inline int AggregateArgument::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int AggregateArgument::keys_size() const {
  return _internal_keys_size();
}
inline void AggregateArgument::clear_keys() {
  _impl_.keys_.Clear();
}
inline std::string* AggregateArgument::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.AggregateArgument.keys)
  return _s;
}
inline const std::string& AggregateArgument::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const std::string& AggregateArgument::keys(int index) const {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggregateArgument.keys)
  return _internal_keys(index);
}
inline std::string* AggregateArgument::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AggregateArgument.keys)
  return _impl_.keys_.Mutable(index);
}
inline void AggregateArgument::set_keys(int index, const std::string& value) {
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::set_keys(int index, std::string&& value) {
  _impl_.keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::set_keys(int index, const void* value, size_t size) {
  _impl_.keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.AggregateArgument.keys)
}
inline std::string* AggregateArgument::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline void AggregateArgument::add_keys(const std::string& value) {
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::add_keys(std::string&& value) {
  _impl_.keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::add_keys(const void* value, size_t size) {
  _impl_.keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.AggregateArgument.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AggregateArgument::keys() const {
  // @@protoc_insertion_point(field_list:PicachvMessages.AggregateArgument.keys)
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AggregateArgument::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.AggregateArgument.keys)
  return &_impl_.keys_;
}

// repeated bytes aggs_uuid = 2;
inline int AggregateArgument::_internal_aggs_uuid_size() const {
  return _impl_.aggs_uuid_.size();
}
inline int AggregateArgument::aggs_uuid_size() const {
  return _internal_aggs_uuid_size();
}
inline void AggregateArgument::clear_aggs_uuid() {
  _impl_.aggs_uuid_.Clear();
}
inline std::string* AggregateArgument::add_aggs_uuid() {
  std::string* _s = _internal_add_aggs_uuid();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.AggregateArgument.aggs_uuid)
  return _s;
}
inline const std::string& AggregateArgument::_internal_aggs_uuid(int index) const {
  return _impl_.aggs_uuid_.Get(index);
}
inline const std::string& AggregateArgument::aggs_uuid(int index) const {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggregateArgument.aggs_uuid)
  return _internal_aggs_uuid(index);
}
inline std::string* AggregateArgument::mutable_aggs_uuid(int index) {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AggregateArgument.aggs_uuid)
  return _impl_.aggs_uuid_.Mutable(index);
}
inline void AggregateArgument::set_aggs_uuid(int index, const std::string& value) {
  _impl_.aggs_uuid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::set_aggs_uuid(int index, std::string&& value) {
  _impl_.aggs_uuid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::set_aggs_uuid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.aggs_uuid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::set_aggs_uuid(int index, const void* value, size_t size) {
  _impl_.aggs_uuid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline std::string* AggregateArgument::_internal_add_aggs_uuid() {
  return _impl_.aggs_uuid_.Add();
}
inline void AggregateArgument::add_aggs_uuid(const std::string& value) {
  _impl_.aggs_uuid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::add_aggs_uuid(std::string&& value) {
  _impl_.aggs_uuid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::add_aggs_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.aggs_uuid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::add_aggs_uuid(const void* value, size_t size) {
  _impl_.aggs_uuid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AggregateArgument::aggs_uuid() const {
  // @@protoc_insertion_point(field_list:PicachvMessages.AggregateArgument.aggs_uuid)
  return _impl_.aggs_uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AggregateArgument::mutable_aggs_uuid() {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.AggregateArgument.aggs_uuid)
  return &_impl_.aggs_uuid_;
}

// bool maintain_order = 3;
inline void AggregateArgument::clear_maintain_order() {
  _impl_.maintain_order_ = false;
}
inline bool AggregateArgument::_internal_maintain_order() const {
  return _impl_.maintain_order_;
}
inline bool AggregateArgument::maintain_order() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggregateArgument.maintain_order)
  return _internal_maintain_order();
}
inline void AggregateArgument::_internal_set_maintain_order(bool value) {
  
  _impl_.maintain_order_ = value;
}
inline void AggregateArgument::set_maintain_order(bool value) {
  _internal_set_maintain_order(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.maintain_order)
}

// .PicachvMessages.GroupByProxy group_by_proxy = 4;
inline bool AggregateArgument::_internal_has_group_by_proxy() const {
  return this != internal_default_instance() && _impl_.group_by_proxy_ != nullptr;
}
inline bool AggregateArgument::has_group_by_proxy() const {
  return _internal_has_group_by_proxy();
}
inline const ::PicachvMessages::GroupByProxy& AggregateArgument::_internal_group_by_proxy() const {
  const ::PicachvMessages::GroupByProxy* p = _impl_.group_by_proxy_;
  return p != nullptr ? *p : reinterpret_cast<const ::PicachvMessages::GroupByProxy&>(
      ::PicachvMessages::_GroupByProxy_default_instance_);
}
inline const ::PicachvMessages::GroupByProxy& AggregateArgument::group_by_proxy() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggregateArgument.group_by_proxy)
  return _internal_group_by_proxy();
}
inline void AggregateArgument::unsafe_arena_set_allocated_group_by_proxy(
    ::PicachvMessages::GroupByProxy* group_by_proxy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_by_proxy_);
  }
  _impl_.group_by_proxy_ = group_by_proxy;
  if (group_by_proxy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.AggregateArgument.group_by_proxy)
}
inline ::PicachvMessages::GroupByProxy* AggregateArgument::release_group_by_proxy() {
  
  ::PicachvMessages::GroupByProxy* temp = _impl_.group_by_proxy_;
  _impl_.group_by_proxy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PicachvMessages::GroupByProxy* AggregateArgument::unsafe_arena_release_group_by_proxy() {
  // @@protoc_insertion_point(field_release:PicachvMessages.AggregateArgument.group_by_proxy)
  
  ::PicachvMessages::GroupByProxy* temp = _impl_.group_by_proxy_;
  _impl_.group_by_proxy_ = nullptr;
  return temp;
}
inline ::PicachvMessages::GroupByProxy* AggregateArgument::_internal_mutable_group_by_proxy() {
  
  if (_impl_.group_by_proxy_ == nullptr) {
    auto* p = CreateMaybeMessage<::PicachvMessages::GroupByProxy>(GetArenaForAllocation());
    _impl_.group_by_proxy_ = p;
  }
  return _impl_.group_by_proxy_;
}
inline ::PicachvMessages::GroupByProxy* AggregateArgument::mutable_group_by_proxy() {
  ::PicachvMessages::GroupByProxy* _msg = _internal_mutable_group_by_proxy();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AggregateArgument.group_by_proxy)
  return _msg;
}
inline void AggregateArgument::set_allocated_group_by_proxy(::PicachvMessages::GroupByProxy* group_by_proxy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_by_proxy_);
  }
  if (group_by_proxy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_by_proxy));
    if (message_arena != submessage_arena) {
      group_by_proxy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group_by_proxy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_by_proxy_ = group_by_proxy;
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.AggregateArgument.group_by_proxy)
}

// repeated string output_schema = 5;
inline int AggregateArgument::_internal_output_schema_size() const {
  return _impl_.output_schema_.size();
}
inline int AggregateArgument::output_schema_size() const {
  return _internal_output_schema_size();
}
inline void AggregateArgument::clear_output_schema() {
  _impl_.output_schema_.Clear();
}
inline std::string* AggregateArgument::add_output_schema() {
  std::string* _s = _internal_add_output_schema();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.AggregateArgument.output_schema)
  return _s;
}
inline const std::string& AggregateArgument::_internal_output_schema(int index) const {
  return _impl_.output_schema_.Get(index);
}
inline const std::string& AggregateArgument::output_schema(int index) const {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggregateArgument.output_schema)
  return _internal_output_schema(index);
}
inline std::string* AggregateArgument::mutable_output_schema(int index) {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AggregateArgument.output_schema)
  return _impl_.output_schema_.Mutable(index);
}
inline void AggregateArgument::set_output_schema(int index, const std::string& value) {
  _impl_.output_schema_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::set_output_schema(int index, std::string&& value) {
  _impl_.output_schema_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::set_output_schema(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.output_schema_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::set_output_schema(int index, const char* value, size_t size) {
  _impl_.output_schema_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.AggregateArgument.output_schema)
}
inline std::string* AggregateArgument::_internal_add_output_schema() {
  return _impl_.output_schema_.Add();
}
inline void AggregateArgument::add_output_schema(const std::string& value) {
  _impl_.output_schema_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::add_output_schema(std::string&& value) {
  _impl_.output_schema_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::add_output_schema(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.output_schema_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::add_output_schema(const char* value, size_t size) {
  _impl_.output_schema_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.AggregateArgument.output_schema)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AggregateArgument::output_schema() const {
  // @@protoc_insertion_point(field_list:PicachvMessages.AggregateArgument.output_schema)
  return _impl_.output_schema_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AggregateArgument::mutable_output_schema() {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.AggregateArgument.output_schema)
  return &_impl_.output_schema_;
}

// -------------------------------------------------------------------

// PlanArgument

// .PicachvMessages.SelectArgument select = 1;
inline bool PlanArgument::_internal_has_select() const {
  return argument_case() == kSelect;
}
inline bool PlanArgument::has_select() const {
  return _internal_has_select();
}
inline void PlanArgument::set_has_select() {
  _impl_._oneof_case_[0] = kSelect;
}
inline void PlanArgument::clear_select() {
  if (_internal_has_select()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.argument_.select_;
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::SelectArgument* PlanArgument::release_select() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.select)
  if (_internal_has_select()) {
    clear_has_argument();
    ::PicachvMessages::SelectArgument* temp = _impl_.argument_.select_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::SelectArgument& PlanArgument::_internal_select() const {
  return _internal_has_select()
      ? *_impl_.argument_.select_
      : reinterpret_cast< ::PicachvMessages::SelectArgument&>(::PicachvMessages::_SelectArgument_default_instance_);
}
inline const ::PicachvMessages::SelectArgument& PlanArgument::select() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.select)
  return _internal_select();
}
inline ::PicachvMessages::SelectArgument* PlanArgument::unsafe_arena_release_select() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.PlanArgument.select)
  if (_internal_has_select()) {
    clear_has_argument();
    ::PicachvMessages::SelectArgument* temp = _impl_.argument_.select_;
    _impl_.argument_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanArgument::unsafe_arena_set_allocated_select(::PicachvMessages::SelectArgument* select) {
  clear_argument();
  if (select) {
    set_has_select();
    _impl_.argument_.select_ = select;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.select)
}
inline ::PicachvMessages::SelectArgument* PlanArgument::_internal_mutable_select() {
  if (!_internal_has_select()) {
    clear_argument();
    set_has_select();
    _impl_.argument_.select_ = CreateMaybeMessage< ::PicachvMessages::SelectArgument >(GetArenaForAllocation());
  }
  return _impl_.argument_.select_;
}
inline ::PicachvMessages::SelectArgument* PlanArgument::mutable_select() {
  ::PicachvMessages::SelectArgument* _msg = _internal_mutable_select();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.select)
  return _msg;
}

// .PicachvMessages.ProjectionArgument projection = 2;
inline bool PlanArgument::_internal_has_projection() const {
  return argument_case() == kProjection;
}
inline bool PlanArgument::has_projection() const {
  return _internal_has_projection();
}
inline void PlanArgument::set_has_projection() {
  _impl_._oneof_case_[0] = kProjection;
}
inline void PlanArgument::clear_projection() {
  if (_internal_has_projection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.argument_.projection_;
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::ProjectionArgument* PlanArgument::release_projection() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.projection)
  if (_internal_has_projection()) {
    clear_has_argument();
    ::PicachvMessages::ProjectionArgument* temp = _impl_.argument_.projection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.projection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::ProjectionArgument& PlanArgument::_internal_projection() const {
  return _internal_has_projection()
      ? *_impl_.argument_.projection_
      : reinterpret_cast< ::PicachvMessages::ProjectionArgument&>(::PicachvMessages::_ProjectionArgument_default_instance_);
}
inline const ::PicachvMessages::ProjectionArgument& PlanArgument::projection() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.projection)
  return _internal_projection();
}
inline ::PicachvMessages::ProjectionArgument* PlanArgument::unsafe_arena_release_projection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.PlanArgument.projection)
  if (_internal_has_projection()) {
    clear_has_argument();
    ::PicachvMessages::ProjectionArgument* temp = _impl_.argument_.projection_;
    _impl_.argument_.projection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanArgument::unsafe_arena_set_allocated_projection(::PicachvMessages::ProjectionArgument* projection) {
  clear_argument();
  if (projection) {
    set_has_projection();
    _impl_.argument_.projection_ = projection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.projection)
}
inline ::PicachvMessages::ProjectionArgument* PlanArgument::_internal_mutable_projection() {
  if (!_internal_has_projection()) {
    clear_argument();
    set_has_projection();
    _impl_.argument_.projection_ = CreateMaybeMessage< ::PicachvMessages::ProjectionArgument >(GetArenaForAllocation());
  }
  return _impl_.argument_.projection_;
}
inline ::PicachvMessages::ProjectionArgument* PlanArgument::mutable_projection() {
  ::PicachvMessages::ProjectionArgument* _msg = _internal_mutable_projection();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.projection)
  return _msg;
}

// .PicachvMessages.AggregateArgument aggregate = 3;
inline bool PlanArgument::_internal_has_aggregate() const {
  return argument_case() == kAggregate;
}
inline bool PlanArgument::has_aggregate() const {
  return _internal_has_aggregate();
}
inline void PlanArgument::set_has_aggregate() {
  _impl_._oneof_case_[0] = kAggregate;
}
inline void PlanArgument::clear_aggregate() {
  if (_internal_has_aggregate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.argument_.aggregate_;
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::AggregateArgument* PlanArgument::release_aggregate() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.aggregate)
  if (_internal_has_aggregate()) {
    clear_has_argument();
    ::PicachvMessages::AggregateArgument* temp = _impl_.argument_.aggregate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::AggregateArgument& PlanArgument::_internal_aggregate() const {
  return _internal_has_aggregate()
      ? *_impl_.argument_.aggregate_
      : reinterpret_cast< ::PicachvMessages::AggregateArgument&>(::PicachvMessages::_AggregateArgument_default_instance_);
}
inline const ::PicachvMessages::AggregateArgument& PlanArgument::aggregate() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.aggregate)
  return _internal_aggregate();
}
inline ::PicachvMessages::AggregateArgument* PlanArgument::unsafe_arena_release_aggregate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.PlanArgument.aggregate)
  if (_internal_has_aggregate()) {
    clear_has_argument();
    ::PicachvMessages::AggregateArgument* temp = _impl_.argument_.aggregate_;
    _impl_.argument_.aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanArgument::unsafe_arena_set_allocated_aggregate(::PicachvMessages::AggregateArgument* aggregate) {
  clear_argument();
  if (aggregate) {
    set_has_aggregate();
    _impl_.argument_.aggregate_ = aggregate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.aggregate)
}
inline ::PicachvMessages::AggregateArgument* PlanArgument::_internal_mutable_aggregate() {
  if (!_internal_has_aggregate()) {
    clear_argument();
    set_has_aggregate();
    _impl_.argument_.aggregate_ = CreateMaybeMessage< ::PicachvMessages::AggregateArgument >(GetArenaForAllocation());
  }
  return _impl_.argument_.aggregate_;
}
inline ::PicachvMessages::AggregateArgument* PlanArgument::mutable_aggregate() {
  ::PicachvMessages::AggregateArgument* _msg = _internal_mutable_aggregate();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.aggregate)
  return _msg;
}

// .PicachvMessages.GetDataArgument get_data = 4;
inline bool PlanArgument::_internal_has_get_data() const {
  return argument_case() == kGetData;
}
inline bool PlanArgument::has_get_data() const {
  return _internal_has_get_data();
}
inline void PlanArgument::set_has_get_data() {
  _impl_._oneof_case_[0] = kGetData;
}
inline void PlanArgument::clear_get_data() {
  if (_internal_has_get_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.argument_.get_data_;
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::GetDataArgument* PlanArgument::release_get_data() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.get_data)
  if (_internal_has_get_data()) {
    clear_has_argument();
    ::PicachvMessages::GetDataArgument* temp = _impl_.argument_.get_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.get_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::GetDataArgument& PlanArgument::_internal_get_data() const {
  return _internal_has_get_data()
      ? *_impl_.argument_.get_data_
      : reinterpret_cast< ::PicachvMessages::GetDataArgument&>(::PicachvMessages::_GetDataArgument_default_instance_);
}
inline const ::PicachvMessages::GetDataArgument& PlanArgument::get_data() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.get_data)
  return _internal_get_data();
}
inline ::PicachvMessages::GetDataArgument* PlanArgument::unsafe_arena_release_get_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.PlanArgument.get_data)
  if (_internal_has_get_data()) {
    clear_has_argument();
    ::PicachvMessages::GetDataArgument* temp = _impl_.argument_.get_data_;
    _impl_.argument_.get_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanArgument::unsafe_arena_set_allocated_get_data(::PicachvMessages::GetDataArgument* get_data) {
  clear_argument();
  if (get_data) {
    set_has_get_data();
    _impl_.argument_.get_data_ = get_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.get_data)
}
inline ::PicachvMessages::GetDataArgument* PlanArgument::_internal_mutable_get_data() {
  if (!_internal_has_get_data()) {
    clear_argument();
    set_has_get_data();
    _impl_.argument_.get_data_ = CreateMaybeMessage< ::PicachvMessages::GetDataArgument >(GetArenaForAllocation());
  }
  return _impl_.argument_.get_data_;
}
inline ::PicachvMessages::GetDataArgument* PlanArgument::mutable_get_data() {
  ::PicachvMessages::GetDataArgument* _msg = _internal_mutable_get_data();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.get_data)
  return _msg;
}

// .PicachvMessages.TransformArgument transform = 5;
inline bool PlanArgument::_internal_has_transform() const {
  return argument_case() == kTransform;
}
inline bool PlanArgument::has_transform() const {
  return _internal_has_transform();
}
inline void PlanArgument::set_has_transform() {
  _impl_._oneof_case_[0] = kTransform;
}
inline void PlanArgument::clear_transform() {
  if (_internal_has_transform()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.argument_.transform_;
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::TransformArgument* PlanArgument::release_transform() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.transform)
  if (_internal_has_transform()) {
    clear_has_argument();
    ::PicachvMessages::TransformArgument* temp = _impl_.argument_.transform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::TransformArgument& PlanArgument::_internal_transform() const {
  return _internal_has_transform()
      ? *_impl_.argument_.transform_
      : reinterpret_cast< ::PicachvMessages::TransformArgument&>(::PicachvMessages::_TransformArgument_default_instance_);
}
inline const ::PicachvMessages::TransformArgument& PlanArgument::transform() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.transform)
  return _internal_transform();
}
inline ::PicachvMessages::TransformArgument* PlanArgument::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.PlanArgument.transform)
  if (_internal_has_transform()) {
    clear_has_argument();
    ::PicachvMessages::TransformArgument* temp = _impl_.argument_.transform_;
    _impl_.argument_.transform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanArgument::unsafe_arena_set_allocated_transform(::PicachvMessages::TransformArgument* transform) {
  clear_argument();
  if (transform) {
    set_has_transform();
    _impl_.argument_.transform_ = transform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.transform)
}
inline ::PicachvMessages::TransformArgument* PlanArgument::_internal_mutable_transform() {
  if (!_internal_has_transform()) {
    clear_argument();
    set_has_transform();
    _impl_.argument_.transform_ = CreateMaybeMessage< ::PicachvMessages::TransformArgument >(GetArenaForAllocation());
  }
  return _impl_.argument_.transform_;
}
inline ::PicachvMessages::TransformArgument* PlanArgument::mutable_transform() {
  ::PicachvMessages::TransformArgument* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.transform)
  return _msg;
}

// .PicachvMessages.HstackArgument hstack = 6;
inline bool PlanArgument::_internal_has_hstack() const {
  return argument_case() == kHstack;
}
inline bool PlanArgument::has_hstack() const {
  return _internal_has_hstack();
}
inline void PlanArgument::set_has_hstack() {
  _impl_._oneof_case_[0] = kHstack;
}
inline void PlanArgument::clear_hstack() {
  if (_internal_has_hstack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.argument_.hstack_;
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::HstackArgument* PlanArgument::release_hstack() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.hstack)
  if (_internal_has_hstack()) {
    clear_has_argument();
    ::PicachvMessages::HstackArgument* temp = _impl_.argument_.hstack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.hstack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::HstackArgument& PlanArgument::_internal_hstack() const {
  return _internal_has_hstack()
      ? *_impl_.argument_.hstack_
      : reinterpret_cast< ::PicachvMessages::HstackArgument&>(::PicachvMessages::_HstackArgument_default_instance_);
}
inline const ::PicachvMessages::HstackArgument& PlanArgument::hstack() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.hstack)
  return _internal_hstack();
}
inline ::PicachvMessages::HstackArgument* PlanArgument::unsafe_arena_release_hstack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.PlanArgument.hstack)
  if (_internal_has_hstack()) {
    clear_has_argument();
    ::PicachvMessages::HstackArgument* temp = _impl_.argument_.hstack_;
    _impl_.argument_.hstack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanArgument::unsafe_arena_set_allocated_hstack(::PicachvMessages::HstackArgument* hstack) {
  clear_argument();
  if (hstack) {
    set_has_hstack();
    _impl_.argument_.hstack_ = hstack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.hstack)
}
inline ::PicachvMessages::HstackArgument* PlanArgument::_internal_mutable_hstack() {
  if (!_internal_has_hstack()) {
    clear_argument();
    set_has_hstack();
    _impl_.argument_.hstack_ = CreateMaybeMessage< ::PicachvMessages::HstackArgument >(GetArenaForAllocation());
  }
  return _impl_.argument_.hstack_;
}
inline ::PicachvMessages::HstackArgument* PlanArgument::mutable_hstack() {
  ::PicachvMessages::HstackArgument* _msg = _internal_mutable_hstack();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.hstack)
  return _msg;
}

// .PicachvMessages.TransformInfo transform_info = 7;
inline bool PlanArgument::_internal_has_transform_info() const {
  return this != internal_default_instance() && _impl_.transform_info_ != nullptr;
}
inline bool PlanArgument::has_transform_info() const {
  return _internal_has_transform_info();
}
inline const ::PicachvMessages::TransformInfo& PlanArgument::_internal_transform_info() const {
  const ::PicachvMessages::TransformInfo* p = _impl_.transform_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PicachvMessages::TransformInfo&>(
      ::PicachvMessages::_TransformInfo_default_instance_);
}
inline const ::PicachvMessages::TransformInfo& PlanArgument::transform_info() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.transform_info)
  return _internal_transform_info();
}
inline void PlanArgument::unsafe_arena_set_allocated_transform_info(
    ::PicachvMessages::TransformInfo* transform_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_info_);
  }
  _impl_.transform_info_ = transform_info;
  if (transform_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.transform_info)
}
inline ::PicachvMessages::TransformInfo* PlanArgument::release_transform_info() {
  
  ::PicachvMessages::TransformInfo* temp = _impl_.transform_info_;
  _impl_.transform_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PicachvMessages::TransformInfo* PlanArgument::unsafe_arena_release_transform_info() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.transform_info)
  
  ::PicachvMessages::TransformInfo* temp = _impl_.transform_info_;
  _impl_.transform_info_ = nullptr;
  return temp;
}
inline ::PicachvMessages::TransformInfo* PlanArgument::_internal_mutable_transform_info() {
  
  if (_impl_.transform_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PicachvMessages::TransformInfo>(GetArenaForAllocation());
    _impl_.transform_info_ = p;
  }
  return _impl_.transform_info_;
}
inline ::PicachvMessages::TransformInfo* PlanArgument::mutable_transform_info() {
  ::PicachvMessages::TransformInfo* _msg = _internal_mutable_transform_info();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.transform_info)
  return _msg;
}
inline void PlanArgument::set_allocated_transform_info(::PicachvMessages::TransformInfo* transform_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_info_);
  }
  if (transform_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform_info));
    if (message_arena != submessage_arena) {
      transform_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transform_info_ = transform_info;
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.PlanArgument.transform_info)
}

inline bool PlanArgument::has_argument() const {
  return argument_case() != ARGUMENT_NOT_SET;
}
inline void PlanArgument::clear_has_argument() {
  _impl_._oneof_case_[0] = ARGUMENT_NOT_SET;
}
inline PlanArgument::ArgumentCase PlanArgument::argument_case() const {
  return PlanArgument::ArgumentCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace PicachvMessages

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_plan_5fargs_2eproto
