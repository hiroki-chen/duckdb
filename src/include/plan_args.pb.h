// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: plan_args.proto
// Protobuf C++ Version: 5.28.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_plan_5fargs_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_plan_5fargs_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "basic.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_plan_5fargs_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_plan_5fargs_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_plan_5fargs_2eproto;
namespace PicachvMessages {
class AggregateArgument;
struct AggregateArgumentDefaultTypeInternal;
extern AggregateArgumentDefaultTypeInternal _AggregateArgument_default_instance_;
class GetDataArgument;
struct GetDataArgumentDefaultTypeInternal;
extern GetDataArgumentDefaultTypeInternal _GetDataArgument_default_instance_;
class GetDataFromFileArgument;
struct GetDataFromFileArgumentDefaultTypeInternal;
extern GetDataFromFileArgumentDefaultTypeInternal _GetDataFromFileArgument_default_instance_;
class GetDataInMemory;
struct GetDataInMemoryDefaultTypeInternal;
extern GetDataInMemoryDefaultTypeInternal _GetDataInMemory_default_instance_;
class PlanArgument;
struct PlanArgumentDefaultTypeInternal;
extern PlanArgumentDefaultTypeInternal _PlanArgument_default_instance_;
class ProjectionArgument;
struct ProjectionArgumentDefaultTypeInternal;
extern ProjectionArgumentDefaultTypeInternal _ProjectionArgument_default_instance_;
class SelectArgument;
struct SelectArgumentDefaultTypeInternal;
extern SelectArgumentDefaultTypeInternal _SelectArgument_default_instance_;
}  // namespace PicachvMessages
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace PicachvMessages {

// ===================================================================


// -------------------------------------------------------------------

class SelectArgument final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.SelectArgument) */ {
 public:
  inline SelectArgument() : SelectArgument(nullptr) {}
  ~SelectArgument() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SelectArgument(
      ::google::protobuf::internal::ConstantInitialized);

  inline SelectArgument(const SelectArgument& from) : SelectArgument(nullptr, from) {}
  inline SelectArgument(SelectArgument&& from) noexcept
      : SelectArgument(nullptr, std::move(from)) {}
  inline SelectArgument& operator=(const SelectArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectArgument& operator=(SelectArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectArgument* internal_default_instance() {
    return reinterpret_cast<const SelectArgument*>(
        &_SelectArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SelectArgument& a, SelectArgument& b) { a.Swap(&b); }
  inline void Swap(SelectArgument* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectArgument* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectArgument* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SelectArgument>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SelectArgument& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SelectArgument& from) { SelectArgument::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SelectArgument* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.SelectArgument"; }

 protected:
  explicit SelectArgument(::google::protobuf::Arena* arena);
  SelectArgument(::google::protobuf::Arena* arena, const SelectArgument& from);
  SelectArgument(::google::protobuf::Arena* arena, SelectArgument&& from) noexcept
      : SelectArgument(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPredUuidFieldNumber = 1,
  };
  // bytes pred_uuid = 1;
  void clear_pred_uuid() ;
  const std::string& pred_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pred_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_pred_uuid();
  PROTOBUF_NODISCARD std::string* release_pred_uuid();
  void set_allocated_pred_uuid(std::string* value);

  private:
  const std::string& _internal_pred_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pred_uuid(
      const std::string& value);
  std::string* _internal_mutable_pred_uuid();

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.SelectArgument)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SelectArgument_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SelectArgument& from_msg);
    ::google::protobuf::internal::ArenaStringPtr pred_uuid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class ProjectionArgument final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.ProjectionArgument) */ {
 public:
  inline ProjectionArgument() : ProjectionArgument(nullptr) {}
  ~ProjectionArgument() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectionArgument(
      ::google::protobuf::internal::ConstantInitialized);

  inline ProjectionArgument(const ProjectionArgument& from) : ProjectionArgument(nullptr, from) {}
  inline ProjectionArgument(ProjectionArgument&& from) noexcept
      : ProjectionArgument(nullptr, std::move(from)) {}
  inline ProjectionArgument& operator=(const ProjectionArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectionArgument& operator=(ProjectionArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectionArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectionArgument* internal_default_instance() {
    return reinterpret_cast<const ProjectionArgument*>(
        &_ProjectionArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ProjectionArgument& a, ProjectionArgument& b) { a.Swap(&b); }
  inline void Swap(ProjectionArgument* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectionArgument* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectionArgument* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ProjectionArgument>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectionArgument& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProjectionArgument& from) { ProjectionArgument::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProjectionArgument* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.ProjectionArgument"; }

 protected:
  explicit ProjectionArgument(::google::protobuf::Arena* arena);
  ProjectionArgument(::google::protobuf::Arena* arena, const ProjectionArgument& from);
  ProjectionArgument(::google::protobuf::Arena* arena, ProjectionArgument&& from) noexcept
      : ProjectionArgument(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExpressionFieldNumber = 1,
  };
  // repeated bytes expression = 1;
  int expression_size() const;
  private:
  int _internal_expression_size() const;

  public:
  void clear_expression() ;
  const std::string& expression(int index) const;
  std::string* mutable_expression(int index);
  void set_expression(int index, const std::string& value);
  void set_expression(int index, std::string&& value);
  void set_expression(int index, const char* value);
  void set_expression(int index, const void* value, std::size_t size);
  void set_expression(int index, absl::string_view value);
  std::string* add_expression();
  void add_expression(const std::string& value);
  void add_expression(std::string&& value);
  void add_expression(const char* value);
  void add_expression(const void* value, std::size_t size);
  void add_expression(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& expression() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_expression();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_expression() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_expression();

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.ProjectionArgument)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ProjectionArgument_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ProjectionArgument& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> expression_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class GetDataInMemory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.GetDataInMemory) */ {
 public:
  inline GetDataInMemory() : GetDataInMemory(nullptr) {}
  ~GetDataInMemory() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetDataInMemory(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetDataInMemory(const GetDataInMemory& from) : GetDataInMemory(nullptr, from) {}
  inline GetDataInMemory(GetDataInMemory&& from) noexcept
      : GetDataInMemory(nullptr, std::move(from)) {}
  inline GetDataInMemory& operator=(const GetDataInMemory& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataInMemory& operator=(GetDataInMemory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataInMemory& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataInMemory* internal_default_instance() {
    return reinterpret_cast<const GetDataInMemory*>(
        &_GetDataInMemory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(GetDataInMemory& a, GetDataInMemory& b) { a.Swap(&b); }
  inline void Swap(GetDataInMemory* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataInMemory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataInMemory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetDataInMemory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetDataInMemory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetDataInMemory& from) { GetDataInMemory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetDataInMemory* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.GetDataInMemory"; }

 protected:
  explicit GetDataInMemory(::google::protobuf::Arena* arena);
  GetDataInMemory(::google::protobuf::Arena* arena, const GetDataInMemory& from);
  GetDataInMemory(::google::protobuf::Arena* arena, GetDataInMemory&& from) noexcept
      : GetDataInMemory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProjectedListFieldNumber = 3,
    kDfUuidFieldNumber = 1,
    kPredFieldNumber = 2,
  };
  // repeated string projected_list = 3;
  int projected_list_size() const;
  private:
  int _internal_projected_list_size() const;

  public:
  void clear_projected_list() ;
  const std::string& projected_list(int index) const;
  std::string* mutable_projected_list(int index);
  void set_projected_list(int index, const std::string& value);
  void set_projected_list(int index, std::string&& value);
  void set_projected_list(int index, const char* value);
  void set_projected_list(int index, const char* value, std::size_t size);
  void set_projected_list(int index, absl::string_view value);
  std::string* add_projected_list();
  void add_projected_list(const std::string& value);
  void add_projected_list(std::string&& value);
  void add_projected_list(const char* value);
  void add_projected_list(const char* value, std::size_t size);
  void add_projected_list(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& projected_list() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_projected_list();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_projected_list() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_projected_list();

  public:
  // bytes df_uuid = 1;
  void clear_df_uuid() ;
  const std::string& df_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_df_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_df_uuid();
  PROTOBUF_NODISCARD std::string* release_df_uuid();
  void set_allocated_df_uuid(std::string* value);

  private:
  const std::string& _internal_df_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_df_uuid(
      const std::string& value);
  std::string* _internal_mutable_df_uuid();

  public:
  // optional bytes pred = 2;
  bool has_pred() const;
  void clear_pred() ;
  const std::string& pred() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pred(Arg_&& arg, Args_... args);
  std::string* mutable_pred();
  PROTOBUF_NODISCARD std::string* release_pred();
  void set_allocated_pred(std::string* value);

  private:
  const std::string& _internal_pred() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pred(
      const std::string& value);
  std::string* _internal_mutable_pred();

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.GetDataInMemory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      54, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetDataInMemory_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetDataInMemory& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> projected_list_;
    ::google::protobuf::internal::ArenaStringPtr df_uuid_;
    ::google::protobuf::internal::ArenaStringPtr pred_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class GetDataFromFileArgument final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.GetDataFromFileArgument) */ {
 public:
  inline GetDataFromFileArgument() : GetDataFromFileArgument(nullptr) {}
  ~GetDataFromFileArgument() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetDataFromFileArgument(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetDataFromFileArgument(const GetDataFromFileArgument& from) : GetDataFromFileArgument(nullptr, from) {}
  inline GetDataFromFileArgument(GetDataFromFileArgument&& from) noexcept
      : GetDataFromFileArgument(nullptr, std::move(from)) {}
  inline GetDataFromFileArgument& operator=(const GetDataFromFileArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataFromFileArgument& operator=(GetDataFromFileArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataFromFileArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataFromFileArgument* internal_default_instance() {
    return reinterpret_cast<const GetDataFromFileArgument*>(
        &_GetDataFromFileArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(GetDataFromFileArgument& a, GetDataFromFileArgument& b) { a.Swap(&b); }
  inline void Swap(GetDataFromFileArgument* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataFromFileArgument* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataFromFileArgument* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetDataFromFileArgument>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetDataFromFileArgument& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetDataFromFileArgument& from) { GetDataFromFileArgument::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetDataFromFileArgument* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.GetDataFromFileArgument"; }

 protected:
  explicit GetDataFromFileArgument(::google::protobuf::Arena* arena);
  GetDataFromFileArgument(::google::protobuf::Arena* arena, const GetDataFromFileArgument& from);
  GetDataFromFileArgument(::google::protobuf::Arena* arena, GetDataFromFileArgument&& from) noexcept
      : GetDataFromFileArgument(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 1,
    kDfUuidFieldNumber = 3,
    kFileTypeFieldNumber = 2,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // bytes df_uuid = 3;
  void clear_df_uuid() ;
  const std::string& df_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_df_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_df_uuid();
  PROTOBUF_NODISCARD std::string* release_df_uuid();
  void set_allocated_df_uuid(std::string* value);

  private:
  const std::string& _internal_df_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_df_uuid(
      const std::string& value);
  std::string* _internal_mutable_df_uuid();

  public:
  // .PicachvMessages.FileType file_type = 2;
  void clear_file_type() ;
  ::PicachvMessages::FileType file_type() const;
  void set_file_type(::PicachvMessages::FileType value);

  private:
  ::PicachvMessages::FileType _internal_file_type() const;
  void _internal_set_file_type(::PicachvMessages::FileType value);

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.GetDataFromFileArgument)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      52, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetDataFromFileArgument_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetDataFromFileArgument& from_msg);
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr df_uuid_;
    int file_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class GetDataArgument final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.GetDataArgument) */ {
 public:
  inline GetDataArgument() : GetDataArgument(nullptr) {}
  ~GetDataArgument() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetDataArgument(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetDataArgument(const GetDataArgument& from) : GetDataArgument(nullptr, from) {}
  inline GetDataArgument(GetDataArgument&& from) noexcept
      : GetDataArgument(nullptr, std::move(from)) {}
  inline GetDataArgument& operator=(const GetDataArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataArgument& operator=(GetDataArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataArgument& default_instance() {
    return *internal_default_instance();
  }
  enum DataSourceCase {
    kFromFile = 1,
    kInMemory = 2,
    DATA_SOURCE_NOT_SET = 0,
  };
  static inline const GetDataArgument* internal_default_instance() {
    return reinterpret_cast<const GetDataArgument*>(
        &_GetDataArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(GetDataArgument& a, GetDataArgument& b) { a.Swap(&b); }
  inline void Swap(GetDataArgument* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataArgument* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataArgument* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetDataArgument>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetDataArgument& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetDataArgument& from) { GetDataArgument::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetDataArgument* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.GetDataArgument"; }

 protected:
  explicit GetDataArgument(::google::protobuf::Arena* arena);
  GetDataArgument(::google::protobuf::Arena* arena, const GetDataArgument& from);
  GetDataArgument(::google::protobuf::Arena* arena, GetDataArgument&& from) noexcept
      : GetDataArgument(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromFileFieldNumber = 1,
    kInMemoryFieldNumber = 2,
  };
  // .PicachvMessages.GetDataFromFileArgument from_file = 1;
  bool has_from_file() const;
  private:
  bool _internal_has_from_file() const;

  public:
  void clear_from_file() ;
  const ::PicachvMessages::GetDataFromFileArgument& from_file() const;
  PROTOBUF_NODISCARD ::PicachvMessages::GetDataFromFileArgument* release_from_file();
  ::PicachvMessages::GetDataFromFileArgument* mutable_from_file();
  void set_allocated_from_file(::PicachvMessages::GetDataFromFileArgument* value);
  void unsafe_arena_set_allocated_from_file(::PicachvMessages::GetDataFromFileArgument* value);
  ::PicachvMessages::GetDataFromFileArgument* unsafe_arena_release_from_file();

  private:
  const ::PicachvMessages::GetDataFromFileArgument& _internal_from_file() const;
  ::PicachvMessages::GetDataFromFileArgument* _internal_mutable_from_file();

  public:
  // .PicachvMessages.GetDataInMemory in_memory = 2;
  bool has_in_memory() const;
  private:
  bool _internal_has_in_memory() const;

  public:
  void clear_in_memory() ;
  const ::PicachvMessages::GetDataInMemory& in_memory() const;
  PROTOBUF_NODISCARD ::PicachvMessages::GetDataInMemory* release_in_memory();
  ::PicachvMessages::GetDataInMemory* mutable_in_memory();
  void set_allocated_in_memory(::PicachvMessages::GetDataInMemory* value);
  void unsafe_arena_set_allocated_in_memory(::PicachvMessages::GetDataInMemory* value);
  ::PicachvMessages::GetDataInMemory* unsafe_arena_release_in_memory();

  private:
  const ::PicachvMessages::GetDataInMemory& _internal_in_memory() const;
  ::PicachvMessages::GetDataInMemory* _internal_mutable_in_memory();

  public:
  void clear_data_source();
  DataSourceCase data_source_case() const;
  // @@protoc_insertion_point(class_scope:PicachvMessages.GetDataArgument)
 private:
  class _Internal;
  void set_has_from_file();
  void set_has_in_memory();
  inline bool has_data_source() const;
  inline void clear_has_data_source();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetDataArgument_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetDataArgument& from_msg);
    union DataSourceUnion {
      constexpr DataSourceUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::PicachvMessages::GetDataFromFileArgument* from_file_;
      ::PicachvMessages::GetDataInMemory* in_memory_;
    } data_source_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class AggregateArgument final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.AggregateArgument) */ {
 public:
  inline AggregateArgument() : AggregateArgument(nullptr) {}
  ~AggregateArgument() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AggregateArgument(
      ::google::protobuf::internal::ConstantInitialized);

  inline AggregateArgument(const AggregateArgument& from) : AggregateArgument(nullptr, from) {}
  inline AggregateArgument(AggregateArgument&& from) noexcept
      : AggregateArgument(nullptr, std::move(from)) {}
  inline AggregateArgument& operator=(const AggregateArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateArgument& operator=(AggregateArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateArgument* internal_default_instance() {
    return reinterpret_cast<const AggregateArgument*>(
        &_AggregateArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(AggregateArgument& a, AggregateArgument& b) { a.Swap(&b); }
  inline void Swap(AggregateArgument* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateArgument* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateArgument* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AggregateArgument>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggregateArgument& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AggregateArgument& from) { AggregateArgument::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggregateArgument* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.AggregateArgument"; }

 protected:
  explicit AggregateArgument(::google::protobuf::Arena* arena);
  AggregateArgument(::google::protobuf::Arena* arena, const AggregateArgument& from);
  AggregateArgument(::google::protobuf::Arena* arena, AggregateArgument&& from) noexcept
      : AggregateArgument(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeysFieldNumber = 1,
    kAggsUuidFieldNumber = 2,
    kOutputSchemaFieldNumber = 5,
    kGroupByProxyFieldNumber = 4,
    kMaintainOrderFieldNumber = 3,
  };
  // repeated bytes keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, std::size_t size);
  void set_keys(int index, absl::string_view value);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, std::size_t size);
  void add_keys(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_keys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_keys();

  public:
  // repeated bytes aggs_uuid = 2;
  int aggs_uuid_size() const;
  private:
  int _internal_aggs_uuid_size() const;

  public:
  void clear_aggs_uuid() ;
  const std::string& aggs_uuid(int index) const;
  std::string* mutable_aggs_uuid(int index);
  void set_aggs_uuid(int index, const std::string& value);
  void set_aggs_uuid(int index, std::string&& value);
  void set_aggs_uuid(int index, const char* value);
  void set_aggs_uuid(int index, const void* value, std::size_t size);
  void set_aggs_uuid(int index, absl::string_view value);
  std::string* add_aggs_uuid();
  void add_aggs_uuid(const std::string& value);
  void add_aggs_uuid(std::string&& value);
  void add_aggs_uuid(const char* value);
  void add_aggs_uuid(const void* value, std::size_t size);
  void add_aggs_uuid(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& aggs_uuid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_aggs_uuid();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_aggs_uuid() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_aggs_uuid();

  public:
  // repeated string output_schema = 5;
  int output_schema_size() const;
  private:
  int _internal_output_schema_size() const;

  public:
  void clear_output_schema() ;
  const std::string& output_schema(int index) const;
  std::string* mutable_output_schema(int index);
  void set_output_schema(int index, const std::string& value);
  void set_output_schema(int index, std::string&& value);
  void set_output_schema(int index, const char* value);
  void set_output_schema(int index, const char* value, std::size_t size);
  void set_output_schema(int index, absl::string_view value);
  std::string* add_output_schema();
  void add_output_schema(const std::string& value);
  void add_output_schema(std::string&& value);
  void add_output_schema(const char* value);
  void add_output_schema(const char* value, std::size_t size);
  void add_output_schema(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& output_schema() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_output_schema();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_output_schema() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_output_schema();

  public:
  // .PicachvMessages.GroupByProxy group_by_proxy = 4;
  bool has_group_by_proxy() const;
  void clear_group_by_proxy() ;
  const ::PicachvMessages::GroupByProxy& group_by_proxy() const;
  PROTOBUF_NODISCARD ::PicachvMessages::GroupByProxy* release_group_by_proxy();
  ::PicachvMessages::GroupByProxy* mutable_group_by_proxy();
  void set_allocated_group_by_proxy(::PicachvMessages::GroupByProxy* value);
  void unsafe_arena_set_allocated_group_by_proxy(::PicachvMessages::GroupByProxy* value);
  ::PicachvMessages::GroupByProxy* unsafe_arena_release_group_by_proxy();

  private:
  const ::PicachvMessages::GroupByProxy& _internal_group_by_proxy() const;
  ::PicachvMessages::GroupByProxy* _internal_mutable_group_by_proxy();

  public:
  // bool maintain_order = 3;
  void clear_maintain_order() ;
  bool maintain_order() const;
  void set_maintain_order(bool value);

  private:
  bool _internal_maintain_order() const;
  void _internal_set_maintain_order(bool value);

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.AggregateArgument)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      55, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AggregateArgument_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AggregateArgument& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> keys_;
    ::google::protobuf::RepeatedPtrField<std::string> aggs_uuid_;
    ::google::protobuf::RepeatedPtrField<std::string> output_schema_;
    ::PicachvMessages::GroupByProxy* group_by_proxy_;
    bool maintain_order_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};
// -------------------------------------------------------------------

class PlanArgument final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.PlanArgument) */ {
 public:
  inline PlanArgument() : PlanArgument(nullptr) {}
  ~PlanArgument() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlanArgument(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlanArgument(const PlanArgument& from) : PlanArgument(nullptr, from) {}
  inline PlanArgument(PlanArgument&& from) noexcept
      : PlanArgument(nullptr, std::move(from)) {}
  inline PlanArgument& operator=(const PlanArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanArgument& operator=(PlanArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanArgument& default_instance() {
    return *internal_default_instance();
  }
  enum ArgumentCase {
    kSelect = 1,
    kProjection = 2,
    kAggregate = 3,
    kGetData = 4,
    ARGUMENT_NOT_SET = 0,
  };
  static inline const PlanArgument* internal_default_instance() {
    return reinterpret_cast<const PlanArgument*>(
        &_PlanArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PlanArgument& a, PlanArgument& b) { a.Swap(&b); }
  inline void Swap(PlanArgument* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanArgument* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanArgument* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlanArgument>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlanArgument& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlanArgument& from) { PlanArgument::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlanArgument* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.PlanArgument"; }

 protected:
  explicit PlanArgument(::google::protobuf::Arena* arena);
  PlanArgument(::google::protobuf::Arena* arena, const PlanArgument& from);
  PlanArgument(::google::protobuf::Arena* arena, PlanArgument&& from) noexcept
      : PlanArgument(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSelectFieldNumber = 1,
    kProjectionFieldNumber = 2,
    kAggregateFieldNumber = 3,
    kGetDataFieldNumber = 4,
  };
  // .PicachvMessages.SelectArgument select = 1;
  bool has_select() const;
  private:
  bool _internal_has_select() const;

  public:
  void clear_select() ;
  const ::PicachvMessages::SelectArgument& select() const;
  PROTOBUF_NODISCARD ::PicachvMessages::SelectArgument* release_select();
  ::PicachvMessages::SelectArgument* mutable_select();
  void set_allocated_select(::PicachvMessages::SelectArgument* value);
  void unsafe_arena_set_allocated_select(::PicachvMessages::SelectArgument* value);
  ::PicachvMessages::SelectArgument* unsafe_arena_release_select();

  private:
  const ::PicachvMessages::SelectArgument& _internal_select() const;
  ::PicachvMessages::SelectArgument* _internal_mutable_select();

  public:
  // .PicachvMessages.ProjectionArgument projection = 2;
  bool has_projection() const;
  private:
  bool _internal_has_projection() const;

  public:
  void clear_projection() ;
  const ::PicachvMessages::ProjectionArgument& projection() const;
  PROTOBUF_NODISCARD ::PicachvMessages::ProjectionArgument* release_projection();
  ::PicachvMessages::ProjectionArgument* mutable_projection();
  void set_allocated_projection(::PicachvMessages::ProjectionArgument* value);
  void unsafe_arena_set_allocated_projection(::PicachvMessages::ProjectionArgument* value);
  ::PicachvMessages::ProjectionArgument* unsafe_arena_release_projection();

  private:
  const ::PicachvMessages::ProjectionArgument& _internal_projection() const;
  ::PicachvMessages::ProjectionArgument* _internal_mutable_projection();

  public:
  // .PicachvMessages.AggregateArgument aggregate = 3;
  bool has_aggregate() const;
  private:
  bool _internal_has_aggregate() const;

  public:
  void clear_aggregate() ;
  const ::PicachvMessages::AggregateArgument& aggregate() const;
  PROTOBUF_NODISCARD ::PicachvMessages::AggregateArgument* release_aggregate();
  ::PicachvMessages::AggregateArgument* mutable_aggregate();
  void set_allocated_aggregate(::PicachvMessages::AggregateArgument* value);
  void unsafe_arena_set_allocated_aggregate(::PicachvMessages::AggregateArgument* value);
  ::PicachvMessages::AggregateArgument* unsafe_arena_release_aggregate();

  private:
  const ::PicachvMessages::AggregateArgument& _internal_aggregate() const;
  ::PicachvMessages::AggregateArgument* _internal_mutable_aggregate();

  public:
  // .PicachvMessages.GetDataArgument get_data = 4;
  bool has_get_data() const;
  private:
  bool _internal_has_get_data() const;

  public:
  void clear_get_data() ;
  const ::PicachvMessages::GetDataArgument& get_data() const;
  PROTOBUF_NODISCARD ::PicachvMessages::GetDataArgument* release_get_data();
  ::PicachvMessages::GetDataArgument* mutable_get_data();
  void set_allocated_get_data(::PicachvMessages::GetDataArgument* value);
  void unsafe_arena_set_allocated_get_data(::PicachvMessages::GetDataArgument* value);
  ::PicachvMessages::GetDataArgument* unsafe_arena_release_get_data();

  private:
  const ::PicachvMessages::GetDataArgument& _internal_get_data() const;
  ::PicachvMessages::GetDataArgument* _internal_mutable_get_data();

  public:
  void clear_argument();
  ArgumentCase argument_case() const;
  // @@protoc_insertion_point(class_scope:PicachvMessages.PlanArgument)
 private:
  class _Internal;
  void set_has_select();
  void set_has_projection();
  void set_has_aggregate();
  void set_has_get_data();
  inline bool has_argument() const;
  inline void clear_has_argument();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlanArgument_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlanArgument& from_msg);
    union ArgumentUnion {
      constexpr ArgumentUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::PicachvMessages::SelectArgument* select_;
      ::PicachvMessages::ProjectionArgument* projection_;
      ::PicachvMessages::AggregateArgument* aggregate_;
      ::PicachvMessages::GetDataArgument* get_data_;
    } argument_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_plan_5fargs_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetDataFromFileArgument

// string path = 1;
inline void GetDataFromFileArgument::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& GetDataFromFileArgument::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataFromFileArgument.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetDataFromFileArgument::set_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataFromFileArgument.path)
}
inline std::string* GetDataFromFileArgument::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataFromFileArgument.path)
  return _s;
}
inline const std::string& GetDataFromFileArgument::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_.Get();
}
inline void GetDataFromFileArgument::_internal_set_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(value, GetArena());
}
inline std::string* GetDataFromFileArgument::_internal_mutable_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* GetDataFromFileArgument::release_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataFromFileArgument.path)
  return _impl_.path_.Release();
}
inline void GetDataFromFileArgument::set_allocated_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.GetDataFromFileArgument.path)
}

// .PicachvMessages.FileType file_type = 2;
inline void GetDataFromFileArgument::clear_file_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_type_ = 0;
}
inline ::PicachvMessages::FileType GetDataFromFileArgument::file_type() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataFromFileArgument.file_type)
  return _internal_file_type();
}
inline void GetDataFromFileArgument::set_file_type(::PicachvMessages::FileType value) {
  _internal_set_file_type(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataFromFileArgument.file_type)
}
inline ::PicachvMessages::FileType GetDataFromFileArgument::_internal_file_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::PicachvMessages::FileType>(_impl_.file_type_);
}
inline void GetDataFromFileArgument::_internal_set_file_type(::PicachvMessages::FileType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_type_ = value;
}

// bytes df_uuid = 3;
inline void GetDataFromFileArgument::clear_df_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.df_uuid_.ClearToEmpty();
}
inline const std::string& GetDataFromFileArgument::df_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataFromFileArgument.df_uuid)
  return _internal_df_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetDataFromFileArgument::set_df_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.df_uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataFromFileArgument.df_uuid)
}
inline std::string* GetDataFromFileArgument::mutable_df_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_df_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataFromFileArgument.df_uuid)
  return _s;
}
inline const std::string& GetDataFromFileArgument::_internal_df_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.df_uuid_.Get();
}
inline void GetDataFromFileArgument::_internal_set_df_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.df_uuid_.Set(value, GetArena());
}
inline std::string* GetDataFromFileArgument::_internal_mutable_df_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.df_uuid_.Mutable( GetArena());
}
inline std::string* GetDataFromFileArgument::release_df_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataFromFileArgument.df_uuid)
  return _impl_.df_uuid_.Release();
}
inline void GetDataFromFileArgument::set_allocated_df_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.df_uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.df_uuid_.IsDefault()) {
          _impl_.df_uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.GetDataFromFileArgument.df_uuid)
}

// -------------------------------------------------------------------

// GetDataInMemory

// bytes df_uuid = 1;
inline void GetDataInMemory::clear_df_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.df_uuid_.ClearToEmpty();
}
inline const std::string& GetDataInMemory::df_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataInMemory.df_uuid)
  return _internal_df_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetDataInMemory::set_df_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.df_uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataInMemory.df_uuid)
}
inline std::string* GetDataInMemory::mutable_df_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_df_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataInMemory.df_uuid)
  return _s;
}
inline const std::string& GetDataInMemory::_internal_df_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.df_uuid_.Get();
}
inline void GetDataInMemory::_internal_set_df_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.df_uuid_.Set(value, GetArena());
}
inline std::string* GetDataInMemory::_internal_mutable_df_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.df_uuid_.Mutable( GetArena());
}
inline std::string* GetDataInMemory::release_df_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataInMemory.df_uuid)
  return _impl_.df_uuid_.Release();
}
inline void GetDataInMemory::set_allocated_df_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.df_uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.df_uuid_.IsDefault()) {
          _impl_.df_uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.GetDataInMemory.df_uuid)
}

// optional bytes pred = 2;
inline bool GetDataInMemory::has_pred() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetDataInMemory::clear_pred() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pred_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetDataInMemory::pred() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataInMemory.pred)
  return _internal_pred();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetDataInMemory::set_pred(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pred_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataInMemory.pred)
}
inline std::string* GetDataInMemory::mutable_pred() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pred();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataInMemory.pred)
  return _s;
}
inline const std::string& GetDataInMemory::_internal_pred() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pred_.Get();
}
inline void GetDataInMemory::_internal_set_pred(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pred_.Set(value, GetArena());
}
inline std::string* GetDataInMemory::_internal_mutable_pred() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pred_.Mutable( GetArena());
}
inline std::string* GetDataInMemory::release_pred() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataInMemory.pred)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.pred_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pred_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GetDataInMemory::set_allocated_pred(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pred_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pred_.IsDefault()) {
          _impl_.pred_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.GetDataInMemory.pred)
}

// repeated string projected_list = 3;
inline int GetDataInMemory::_internal_projected_list_size() const {
  return _internal_projected_list().size();
}
inline int GetDataInMemory::projected_list_size() const {
  return _internal_projected_list_size();
}
inline void GetDataInMemory::clear_projected_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.projected_list_.Clear();
}
inline std::string* GetDataInMemory::add_projected_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_projected_list()->Add();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.GetDataInMemory.projected_list)
  return _s;
}
inline const std::string& GetDataInMemory::projected_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataInMemory.projected_list)
  return _internal_projected_list().Get(index);
}
inline std::string* GetDataInMemory::mutable_projected_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataInMemory.projected_list)
  return _internal_mutable_projected_list()->Mutable(index);
}
inline void GetDataInMemory::set_projected_list(int index, const std::string& value) {
  _internal_mutable_projected_list()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataInMemory.projected_list)
}
inline void GetDataInMemory::set_projected_list(int index, std::string&& value) {
  _internal_mutable_projected_list()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.GetDataInMemory.projected_list)
}
inline void GetDataInMemory::set_projected_list(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_projected_list()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.GetDataInMemory.projected_list)
}
inline void GetDataInMemory::set_projected_list(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_projected_list()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.GetDataInMemory.projected_list)
}
inline void GetDataInMemory::set_projected_list(int index, absl::string_view value) {
  _internal_mutable_projected_list()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:PicachvMessages.GetDataInMemory.projected_list)
}
inline void GetDataInMemory::add_projected_list(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_projected_list()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.GetDataInMemory.projected_list)
}
inline void GetDataInMemory::add_projected_list(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_projected_list()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.GetDataInMemory.projected_list)
}
inline void GetDataInMemory::add_projected_list(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_projected_list()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.GetDataInMemory.projected_list)
}
inline void GetDataInMemory::add_projected_list(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_projected_list()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.GetDataInMemory.projected_list)
}
inline void GetDataInMemory::add_projected_list(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_projected_list()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:PicachvMessages.GetDataInMemory.projected_list)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetDataInMemory::projected_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:PicachvMessages.GetDataInMemory.projected_list)
  return _internal_projected_list();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetDataInMemory::mutable_projected_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.GetDataInMemory.projected_list)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_projected_list();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetDataInMemory::_internal_projected_list() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.projected_list_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetDataInMemory::_internal_mutable_projected_list() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.projected_list_;
}

// -------------------------------------------------------------------

// GetDataArgument

// .PicachvMessages.GetDataFromFileArgument from_file = 1;
inline bool GetDataArgument::has_from_file() const {
  return data_source_case() == kFromFile;
}
inline bool GetDataArgument::_internal_has_from_file() const {
  return data_source_case() == kFromFile;
}
inline void GetDataArgument::set_has_from_file() {
  _impl_._oneof_case_[0] = kFromFile;
}
inline void GetDataArgument::clear_from_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_source_case() == kFromFile) {
    if (GetArena() == nullptr) {
      delete _impl_.data_source_.from_file_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.data_source_.from_file_);
    }
    clear_has_data_source();
  }
}
inline ::PicachvMessages::GetDataFromFileArgument* GetDataArgument::release_from_file() {
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataArgument.from_file)
  if (data_source_case() == kFromFile) {
    clear_has_data_source();
    auto* temp = _impl_.data_source_.from_file_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_source_.from_file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::GetDataFromFileArgument& GetDataArgument::_internal_from_file() const {
  return data_source_case() == kFromFile ? *_impl_.data_source_.from_file_ : reinterpret_cast<::PicachvMessages::GetDataFromFileArgument&>(::PicachvMessages::_GetDataFromFileArgument_default_instance_);
}
inline const ::PicachvMessages::GetDataFromFileArgument& GetDataArgument::from_file() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataArgument.from_file)
  return _internal_from_file();
}
inline ::PicachvMessages::GetDataFromFileArgument* GetDataArgument::unsafe_arena_release_from_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.GetDataArgument.from_file)
  if (data_source_case() == kFromFile) {
    clear_has_data_source();
    auto* temp = _impl_.data_source_.from_file_;
    _impl_.data_source_.from_file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetDataArgument::unsafe_arena_set_allocated_from_file(::PicachvMessages::GetDataFromFileArgument* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data_source();
  if (value) {
    set_has_from_file();
    _impl_.data_source_.from_file_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.GetDataArgument.from_file)
}
inline ::PicachvMessages::GetDataFromFileArgument* GetDataArgument::_internal_mutable_from_file() {
  if (data_source_case() != kFromFile) {
    clear_data_source();
    set_has_from_file();
    _impl_.data_source_.from_file_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::GetDataFromFileArgument>(GetArena());
  }
  return _impl_.data_source_.from_file_;
}
inline ::PicachvMessages::GetDataFromFileArgument* GetDataArgument::mutable_from_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::GetDataFromFileArgument* _msg = _internal_mutable_from_file();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataArgument.from_file)
  return _msg;
}

// .PicachvMessages.GetDataInMemory in_memory = 2;
inline bool GetDataArgument::has_in_memory() const {
  return data_source_case() == kInMemory;
}
inline bool GetDataArgument::_internal_has_in_memory() const {
  return data_source_case() == kInMemory;
}
inline void GetDataArgument::set_has_in_memory() {
  _impl_._oneof_case_[0] = kInMemory;
}
inline void GetDataArgument::clear_in_memory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (data_source_case() == kInMemory) {
    if (GetArena() == nullptr) {
      delete _impl_.data_source_.in_memory_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.data_source_.in_memory_);
    }
    clear_has_data_source();
  }
}
inline ::PicachvMessages::GetDataInMemory* GetDataArgument::release_in_memory() {
  // @@protoc_insertion_point(field_release:PicachvMessages.GetDataArgument.in_memory)
  if (data_source_case() == kInMemory) {
    clear_has_data_source();
    auto* temp = _impl_.data_source_.in_memory_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_source_.in_memory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::GetDataInMemory& GetDataArgument::_internal_in_memory() const {
  return data_source_case() == kInMemory ? *_impl_.data_source_.in_memory_ : reinterpret_cast<::PicachvMessages::GetDataInMemory&>(::PicachvMessages::_GetDataInMemory_default_instance_);
}
inline const ::PicachvMessages::GetDataInMemory& GetDataArgument::in_memory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.GetDataArgument.in_memory)
  return _internal_in_memory();
}
inline ::PicachvMessages::GetDataInMemory* GetDataArgument::unsafe_arena_release_in_memory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.GetDataArgument.in_memory)
  if (data_source_case() == kInMemory) {
    clear_has_data_source();
    auto* temp = _impl_.data_source_.in_memory_;
    _impl_.data_source_.in_memory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetDataArgument::unsafe_arena_set_allocated_in_memory(::PicachvMessages::GetDataInMemory* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data_source();
  if (value) {
    set_has_in_memory();
    _impl_.data_source_.in_memory_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.GetDataArgument.in_memory)
}
inline ::PicachvMessages::GetDataInMemory* GetDataArgument::_internal_mutable_in_memory() {
  if (data_source_case() != kInMemory) {
    clear_data_source();
    set_has_in_memory();
    _impl_.data_source_.in_memory_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::GetDataInMemory>(GetArena());
  }
  return _impl_.data_source_.in_memory_;
}
inline ::PicachvMessages::GetDataInMemory* GetDataArgument::mutable_in_memory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::GetDataInMemory* _msg = _internal_mutable_in_memory();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.GetDataArgument.in_memory)
  return _msg;
}

inline bool GetDataArgument::has_data_source() const {
  return data_source_case() != DATA_SOURCE_NOT_SET;
}
inline void GetDataArgument::clear_has_data_source() {
  _impl_._oneof_case_[0] = DATA_SOURCE_NOT_SET;
}
inline GetDataArgument::DataSourceCase GetDataArgument::data_source_case() const {
  return GetDataArgument::DataSourceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SelectArgument

// bytes pred_uuid = 1;
inline void SelectArgument::clear_pred_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pred_uuid_.ClearToEmpty();
}
inline const std::string& SelectArgument::pred_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.SelectArgument.pred_uuid)
  return _internal_pred_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SelectArgument::set_pred_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pred_uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.SelectArgument.pred_uuid)
}
inline std::string* SelectArgument::mutable_pred_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pred_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.SelectArgument.pred_uuid)
  return _s;
}
inline const std::string& SelectArgument::_internal_pred_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pred_uuid_.Get();
}
inline void SelectArgument::_internal_set_pred_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pred_uuid_.Set(value, GetArena());
}
inline std::string* SelectArgument::_internal_mutable_pred_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pred_uuid_.Mutable( GetArena());
}
inline std::string* SelectArgument::release_pred_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.SelectArgument.pred_uuid)
  return _impl_.pred_uuid_.Release();
}
inline void SelectArgument::set_allocated_pred_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pred_uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pred_uuid_.IsDefault()) {
          _impl_.pred_uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.SelectArgument.pred_uuid)
}

// -------------------------------------------------------------------

// ProjectionArgument

// repeated bytes expression = 1;
inline int ProjectionArgument::_internal_expression_size() const {
  return _internal_expression().size();
}
inline int ProjectionArgument::expression_size() const {
  return _internal_expression_size();
}
inline void ProjectionArgument::clear_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expression_.Clear();
}
inline std::string* ProjectionArgument::add_expression()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_expression()->Add();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.ProjectionArgument.expression)
  return _s;
}
inline const std::string& ProjectionArgument::expression(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ProjectionArgument.expression)
  return _internal_expression().Get(index);
}
inline std::string* ProjectionArgument::mutable_expression(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ProjectionArgument.expression)
  return _internal_mutable_expression()->Mutable(index);
}
inline void ProjectionArgument::set_expression(int index, const std::string& value) {
  _internal_mutable_expression()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.ProjectionArgument.expression)
}
inline void ProjectionArgument::set_expression(int index, std::string&& value) {
  _internal_mutable_expression()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.ProjectionArgument.expression)
}
inline void ProjectionArgument::set_expression(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_expression()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.ProjectionArgument.expression)
}
inline void ProjectionArgument::set_expression(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_expression()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.ProjectionArgument.expression)
}
inline void ProjectionArgument::set_expression(int index, absl::string_view value) {
  _internal_mutable_expression()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:PicachvMessages.ProjectionArgument.expression)
}
inline void ProjectionArgument::add_expression(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_expression()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.ProjectionArgument.expression)
}
inline void ProjectionArgument::add_expression(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_expression()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.ProjectionArgument.expression)
}
inline void ProjectionArgument::add_expression(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_expression()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.ProjectionArgument.expression)
}
inline void ProjectionArgument::add_expression(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_expression()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.ProjectionArgument.expression)
}
inline void ProjectionArgument::add_expression(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_expression()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:PicachvMessages.ProjectionArgument.expression)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectionArgument::expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:PicachvMessages.ProjectionArgument.expression)
  return _internal_expression();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectionArgument::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.ProjectionArgument.expression)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_expression();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProjectionArgument::_internal_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expression_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProjectionArgument::_internal_mutable_expression() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.expression_;
}

// -------------------------------------------------------------------

// AggregateArgument

// repeated bytes keys = 1;
inline int AggregateArgument::_internal_keys_size() const {
  return _internal_keys().size();
}
inline int AggregateArgument::keys_size() const {
  return _internal_keys_size();
}
inline void AggregateArgument::clear_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.keys_.Clear();
}
inline std::string* AggregateArgument::add_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_keys()->Add();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.AggregateArgument.keys)
  return _s;
}
inline const std::string& AggregateArgument::keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggregateArgument.keys)
  return _internal_keys().Get(index);
}
inline std::string* AggregateArgument::mutable_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AggregateArgument.keys)
  return _internal_mutable_keys()->Mutable(index);
}
inline void AggregateArgument::set_keys(int index, const std::string& value) {
  _internal_mutable_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::set_keys(int index, std::string&& value) {
  _internal_mutable_keys()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::set_keys(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::set_keys(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_keys()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::set_keys(int index, absl::string_view value) {
  _internal_mutable_keys()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::add_keys(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::add_keys(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_keys()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::add_keys(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::add_keys(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_keys()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.AggregateArgument.keys)
}
inline void AggregateArgument::add_keys(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_keys()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:PicachvMessages.AggregateArgument.keys)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AggregateArgument::keys() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:PicachvMessages.AggregateArgument.keys)
  return _internal_keys();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AggregateArgument::mutable_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.AggregateArgument.keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_keys();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AggregateArgument::_internal_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.keys_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AggregateArgument::_internal_mutable_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.keys_;
}

// repeated bytes aggs_uuid = 2;
inline int AggregateArgument::_internal_aggs_uuid_size() const {
  return _internal_aggs_uuid().size();
}
inline int AggregateArgument::aggs_uuid_size() const {
  return _internal_aggs_uuid_size();
}
inline void AggregateArgument::clear_aggs_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggs_uuid_.Clear();
}
inline std::string* AggregateArgument::add_aggs_uuid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_aggs_uuid()->Add();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.AggregateArgument.aggs_uuid)
  return _s;
}
inline const std::string& AggregateArgument::aggs_uuid(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggregateArgument.aggs_uuid)
  return _internal_aggs_uuid().Get(index);
}
inline std::string* AggregateArgument::mutable_aggs_uuid(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AggregateArgument.aggs_uuid)
  return _internal_mutable_aggs_uuid()->Mutable(index);
}
inline void AggregateArgument::set_aggs_uuid(int index, const std::string& value) {
  _internal_mutable_aggs_uuid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::set_aggs_uuid(int index, std::string&& value) {
  _internal_mutable_aggs_uuid()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::set_aggs_uuid(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_aggs_uuid()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::set_aggs_uuid(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_aggs_uuid()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::set_aggs_uuid(int index, absl::string_view value) {
  _internal_mutable_aggs_uuid()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::add_aggs_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_aggs_uuid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::add_aggs_uuid(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_aggs_uuid()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::add_aggs_uuid(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_aggs_uuid()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::add_aggs_uuid(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_aggs_uuid()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline void AggregateArgument::add_aggs_uuid(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_aggs_uuid()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:PicachvMessages.AggregateArgument.aggs_uuid)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AggregateArgument::aggs_uuid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:PicachvMessages.AggregateArgument.aggs_uuid)
  return _internal_aggs_uuid();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AggregateArgument::mutable_aggs_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.AggregateArgument.aggs_uuid)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_aggs_uuid();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AggregateArgument::_internal_aggs_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aggs_uuid_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AggregateArgument::_internal_mutable_aggs_uuid() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.aggs_uuid_;
}

// bool maintain_order = 3;
inline void AggregateArgument::clear_maintain_order() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintain_order_ = false;
}
inline bool AggregateArgument::maintain_order() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggregateArgument.maintain_order)
  return _internal_maintain_order();
}
inline void AggregateArgument::set_maintain_order(bool value) {
  _internal_set_maintain_order(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.maintain_order)
}
inline bool AggregateArgument::_internal_maintain_order() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.maintain_order_;
}
inline void AggregateArgument::_internal_set_maintain_order(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintain_order_ = value;
}

// .PicachvMessages.GroupByProxy group_by_proxy = 4;
inline bool AggregateArgument::has_group_by_proxy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_by_proxy_ != nullptr);
  return value;
}
inline const ::PicachvMessages::GroupByProxy& AggregateArgument::_internal_group_by_proxy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::PicachvMessages::GroupByProxy* p = _impl_.group_by_proxy_;
  return p != nullptr ? *p : reinterpret_cast<const ::PicachvMessages::GroupByProxy&>(::PicachvMessages::_GroupByProxy_default_instance_);
}
inline const ::PicachvMessages::GroupByProxy& AggregateArgument::group_by_proxy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggregateArgument.group_by_proxy)
  return _internal_group_by_proxy();
}
inline void AggregateArgument::unsafe_arena_set_allocated_group_by_proxy(::PicachvMessages::GroupByProxy* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_by_proxy_);
  }
  _impl_.group_by_proxy_ = reinterpret_cast<::PicachvMessages::GroupByProxy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.AggregateArgument.group_by_proxy)
}
inline ::PicachvMessages::GroupByProxy* AggregateArgument::release_group_by_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PicachvMessages::GroupByProxy* released = _impl_.group_by_proxy_;
  _impl_.group_by_proxy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::PicachvMessages::GroupByProxy* AggregateArgument::unsafe_arena_release_group_by_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.AggregateArgument.group_by_proxy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PicachvMessages::GroupByProxy* temp = _impl_.group_by_proxy_;
  _impl_.group_by_proxy_ = nullptr;
  return temp;
}
inline ::PicachvMessages::GroupByProxy* AggregateArgument::_internal_mutable_group_by_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.group_by_proxy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::GroupByProxy>(GetArena());
    _impl_.group_by_proxy_ = reinterpret_cast<::PicachvMessages::GroupByProxy*>(p);
  }
  return _impl_.group_by_proxy_;
}
inline ::PicachvMessages::GroupByProxy* AggregateArgument::mutable_group_by_proxy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::PicachvMessages::GroupByProxy* _msg = _internal_mutable_group_by_proxy();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AggregateArgument.group_by_proxy)
  return _msg;
}
inline void AggregateArgument::set_allocated_group_by_proxy(::PicachvMessages::GroupByProxy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_by_proxy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.group_by_proxy_ = reinterpret_cast<::PicachvMessages::GroupByProxy*>(value);
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.AggregateArgument.group_by_proxy)
}

// repeated string output_schema = 5;
inline int AggregateArgument::_internal_output_schema_size() const {
  return _internal_output_schema().size();
}
inline int AggregateArgument::output_schema_size() const {
  return _internal_output_schema_size();
}
inline void AggregateArgument::clear_output_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_schema_.Clear();
}
inline std::string* AggregateArgument::add_output_schema()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_output_schema()->Add();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.AggregateArgument.output_schema)
  return _s;
}
inline const std::string& AggregateArgument::output_schema(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggregateArgument.output_schema)
  return _internal_output_schema().Get(index);
}
inline std::string* AggregateArgument::mutable_output_schema(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AggregateArgument.output_schema)
  return _internal_mutable_output_schema()->Mutable(index);
}
inline void AggregateArgument::set_output_schema(int index, const std::string& value) {
  _internal_mutable_output_schema()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::set_output_schema(int index, std::string&& value) {
  _internal_mutable_output_schema()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::set_output_schema(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_output_schema()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::set_output_schema(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_output_schema()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::set_output_schema(int index, absl::string_view value) {
  _internal_mutable_output_schema()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::add_output_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_output_schema()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::add_output_schema(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_output_schema()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::add_output_schema(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_output_schema()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::add_output_schema(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_output_schema()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.AggregateArgument.output_schema)
}
inline void AggregateArgument::add_output_schema(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_output_schema()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:PicachvMessages.AggregateArgument.output_schema)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AggregateArgument::output_schema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:PicachvMessages.AggregateArgument.output_schema)
  return _internal_output_schema();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AggregateArgument::mutable_output_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.AggregateArgument.output_schema)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_output_schema();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AggregateArgument::_internal_output_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_schema_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AggregateArgument::_internal_mutable_output_schema() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.output_schema_;
}

// -------------------------------------------------------------------

// PlanArgument

// .PicachvMessages.SelectArgument select = 1;
inline bool PlanArgument::has_select() const {
  return argument_case() == kSelect;
}
inline bool PlanArgument::_internal_has_select() const {
  return argument_case() == kSelect;
}
inline void PlanArgument::set_has_select() {
  _impl_._oneof_case_[0] = kSelect;
}
inline void PlanArgument::clear_select() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kSelect) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.select_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.select_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::SelectArgument* PlanArgument::release_select() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.select)
  if (argument_case() == kSelect) {
    clear_has_argument();
    auto* temp = _impl_.argument_.select_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::SelectArgument& PlanArgument::_internal_select() const {
  return argument_case() == kSelect ? *_impl_.argument_.select_ : reinterpret_cast<::PicachvMessages::SelectArgument&>(::PicachvMessages::_SelectArgument_default_instance_);
}
inline const ::PicachvMessages::SelectArgument& PlanArgument::select() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.select)
  return _internal_select();
}
inline ::PicachvMessages::SelectArgument* PlanArgument::unsafe_arena_release_select() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.PlanArgument.select)
  if (argument_case() == kSelect) {
    clear_has_argument();
    auto* temp = _impl_.argument_.select_;
    _impl_.argument_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanArgument::unsafe_arena_set_allocated_select(::PicachvMessages::SelectArgument* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_select();
    _impl_.argument_.select_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.select)
}
inline ::PicachvMessages::SelectArgument* PlanArgument::_internal_mutable_select() {
  if (argument_case() != kSelect) {
    clear_argument();
    set_has_select();
    _impl_.argument_.select_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::SelectArgument>(GetArena());
  }
  return _impl_.argument_.select_;
}
inline ::PicachvMessages::SelectArgument* PlanArgument::mutable_select() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::SelectArgument* _msg = _internal_mutable_select();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.select)
  return _msg;
}

// .PicachvMessages.ProjectionArgument projection = 2;
inline bool PlanArgument::has_projection() const {
  return argument_case() == kProjection;
}
inline bool PlanArgument::_internal_has_projection() const {
  return argument_case() == kProjection;
}
inline void PlanArgument::set_has_projection() {
  _impl_._oneof_case_[0] = kProjection;
}
inline void PlanArgument::clear_projection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kProjection) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.projection_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.projection_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::ProjectionArgument* PlanArgument::release_projection() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.projection)
  if (argument_case() == kProjection) {
    clear_has_argument();
    auto* temp = _impl_.argument_.projection_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.projection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::ProjectionArgument& PlanArgument::_internal_projection() const {
  return argument_case() == kProjection ? *_impl_.argument_.projection_ : reinterpret_cast<::PicachvMessages::ProjectionArgument&>(::PicachvMessages::_ProjectionArgument_default_instance_);
}
inline const ::PicachvMessages::ProjectionArgument& PlanArgument::projection() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.projection)
  return _internal_projection();
}
inline ::PicachvMessages::ProjectionArgument* PlanArgument::unsafe_arena_release_projection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.PlanArgument.projection)
  if (argument_case() == kProjection) {
    clear_has_argument();
    auto* temp = _impl_.argument_.projection_;
    _impl_.argument_.projection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanArgument::unsafe_arena_set_allocated_projection(::PicachvMessages::ProjectionArgument* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_projection();
    _impl_.argument_.projection_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.projection)
}
inline ::PicachvMessages::ProjectionArgument* PlanArgument::_internal_mutable_projection() {
  if (argument_case() != kProjection) {
    clear_argument();
    set_has_projection();
    _impl_.argument_.projection_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::ProjectionArgument>(GetArena());
  }
  return _impl_.argument_.projection_;
}
inline ::PicachvMessages::ProjectionArgument* PlanArgument::mutable_projection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::ProjectionArgument* _msg = _internal_mutable_projection();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.projection)
  return _msg;
}

// .PicachvMessages.AggregateArgument aggregate = 3;
inline bool PlanArgument::has_aggregate() const {
  return argument_case() == kAggregate;
}
inline bool PlanArgument::_internal_has_aggregate() const {
  return argument_case() == kAggregate;
}
inline void PlanArgument::set_has_aggregate() {
  _impl_._oneof_case_[0] = kAggregate;
}
inline void PlanArgument::clear_aggregate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kAggregate) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.aggregate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.aggregate_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::AggregateArgument* PlanArgument::release_aggregate() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.aggregate)
  if (argument_case() == kAggregate) {
    clear_has_argument();
    auto* temp = _impl_.argument_.aggregate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::AggregateArgument& PlanArgument::_internal_aggregate() const {
  return argument_case() == kAggregate ? *_impl_.argument_.aggregate_ : reinterpret_cast<::PicachvMessages::AggregateArgument&>(::PicachvMessages::_AggregateArgument_default_instance_);
}
inline const ::PicachvMessages::AggregateArgument& PlanArgument::aggregate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.aggregate)
  return _internal_aggregate();
}
inline ::PicachvMessages::AggregateArgument* PlanArgument::unsafe_arena_release_aggregate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.PlanArgument.aggregate)
  if (argument_case() == kAggregate) {
    clear_has_argument();
    auto* temp = _impl_.argument_.aggregate_;
    _impl_.argument_.aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanArgument::unsafe_arena_set_allocated_aggregate(::PicachvMessages::AggregateArgument* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_aggregate();
    _impl_.argument_.aggregate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.aggregate)
}
inline ::PicachvMessages::AggregateArgument* PlanArgument::_internal_mutable_aggregate() {
  if (argument_case() != kAggregate) {
    clear_argument();
    set_has_aggregate();
    _impl_.argument_.aggregate_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::AggregateArgument>(GetArena());
  }
  return _impl_.argument_.aggregate_;
}
inline ::PicachvMessages::AggregateArgument* PlanArgument::mutable_aggregate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::AggregateArgument* _msg = _internal_mutable_aggregate();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.aggregate)
  return _msg;
}

// .PicachvMessages.GetDataArgument get_data = 4;
inline bool PlanArgument::has_get_data() const {
  return argument_case() == kGetData;
}
inline bool PlanArgument::_internal_has_get_data() const {
  return argument_case() == kGetData;
}
inline void PlanArgument::set_has_get_data() {
  _impl_._oneof_case_[0] = kGetData;
}
inline void PlanArgument::clear_get_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kGetData) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.get_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.get_data_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::GetDataArgument* PlanArgument::release_get_data() {
  // @@protoc_insertion_point(field_release:PicachvMessages.PlanArgument.get_data)
  if (argument_case() == kGetData) {
    clear_has_argument();
    auto* temp = _impl_.argument_.get_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.get_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::GetDataArgument& PlanArgument::_internal_get_data() const {
  return argument_case() == kGetData ? *_impl_.argument_.get_data_ : reinterpret_cast<::PicachvMessages::GetDataArgument&>(::PicachvMessages::_GetDataArgument_default_instance_);
}
inline const ::PicachvMessages::GetDataArgument& PlanArgument::get_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.PlanArgument.get_data)
  return _internal_get_data();
}
inline ::PicachvMessages::GetDataArgument* PlanArgument::unsafe_arena_release_get_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.PlanArgument.get_data)
  if (argument_case() == kGetData) {
    clear_has_argument();
    auto* temp = _impl_.argument_.get_data_;
    _impl_.argument_.get_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanArgument::unsafe_arena_set_allocated_get_data(::PicachvMessages::GetDataArgument* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_get_data();
    _impl_.argument_.get_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.PlanArgument.get_data)
}
inline ::PicachvMessages::GetDataArgument* PlanArgument::_internal_mutable_get_data() {
  if (argument_case() != kGetData) {
    clear_argument();
    set_has_get_data();
    _impl_.argument_.get_data_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::GetDataArgument>(GetArena());
  }
  return _impl_.argument_.get_data_;
}
inline ::PicachvMessages::GetDataArgument* PlanArgument::mutable_get_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::GetDataArgument* _msg = _internal_mutable_get_data();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.PlanArgument.get_data)
  return _msg;
}

inline bool PlanArgument::has_argument() const {
  return argument_case() != ARGUMENT_NOT_SET;
}
inline void PlanArgument::clear_has_argument() {
  _impl_._oneof_case_[0] = ARGUMENT_NOT_SET;
}
inline PlanArgument::ArgumentCase PlanArgument::argument_case() const {
  return PlanArgument::ArgumentCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace PicachvMessages


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_plan_5fargs_2eproto_2epb_2eh
