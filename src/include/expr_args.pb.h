// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: expr_args.proto
// Protobuf C++ Version: 5.28.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_expr_5fargs_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_expr_5fargs_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "basic.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_expr_5fargs_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_expr_5fargs_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_expr_5fargs_2eproto;
namespace PicachvMessages {
class AggExpr;
struct AggExprDefaultTypeInternal;
extern AggExprDefaultTypeInternal _AggExpr_default_instance_;
class AliasExpr;
struct AliasExprDefaultTypeInternal;
extern AliasExprDefaultTypeInternal _AliasExpr_default_instance_;
class ApplyExpr;
struct ApplyExprDefaultTypeInternal;
extern ApplyExprDefaultTypeInternal _ApplyExpr_default_instance_;
class BinaryExpr;
struct BinaryExprDefaultTypeInternal;
extern BinaryExprDefaultTypeInternal _BinaryExpr_default_instance_;
class ColumnExpr;
struct ColumnExprDefaultTypeInternal;
extern ColumnExprDefaultTypeInternal _ColumnExpr_default_instance_;
class ColumnExpr_ColumnNameSpecifier;
struct ColumnExpr_ColumnNameSpecifierDefaultTypeInternal;
extern ColumnExpr_ColumnNameSpecifierDefaultTypeInternal _ColumnExpr_ColumnNameSpecifier_default_instance_;
class ExprArgument;
struct ExprArgumentDefaultTypeInternal;
extern ExprArgumentDefaultTypeInternal _ExprArgument_default_instance_;
class FilterExpr;
struct FilterExprDefaultTypeInternal;
extern FilterExprDefaultTypeInternal _FilterExpr_default_instance_;
class LiteralExpr;
struct LiteralExprDefaultTypeInternal;
extern LiteralExprDefaultTypeInternal _LiteralExpr_default_instance_;
class UnaryExpr;
struct UnaryExprDefaultTypeInternal;
extern UnaryExprDefaultTypeInternal _UnaryExpr_default_instance_;
class WildcardExpr;
struct WildcardExprDefaultTypeInternal;
extern WildcardExprDefaultTypeInternal _WildcardExpr_default_instance_;
}  // namespace PicachvMessages
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace PicachvMessages {

// ===================================================================


// -------------------------------------------------------------------

class WildcardExpr final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:PicachvMessages.WildcardExpr) */ {
 public:
  inline WildcardExpr() : WildcardExpr(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WildcardExpr(
      ::google::protobuf::internal::ConstantInitialized);

  inline WildcardExpr(const WildcardExpr& from) : WildcardExpr(nullptr, from) {}
  inline WildcardExpr(WildcardExpr&& from) noexcept
      : WildcardExpr(nullptr, std::move(from)) {}
  inline WildcardExpr& operator=(const WildcardExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline WildcardExpr& operator=(WildcardExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WildcardExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const WildcardExpr* internal_default_instance() {
    return reinterpret_cast<const WildcardExpr*>(
        &_WildcardExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(WildcardExpr& a, WildcardExpr& b) { a.Swap(&b); }
  inline void Swap(WildcardExpr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WildcardExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WildcardExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<WildcardExpr>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WildcardExpr& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WildcardExpr& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.WildcardExpr"; }

 protected:
  explicit WildcardExpr(::google::protobuf::Arena* arena);
  WildcardExpr(::google::protobuf::Arena* arena, const WildcardExpr& from);
  WildcardExpr(::google::protobuf::Arena* arena, WildcardExpr&& from) noexcept
      : WildcardExpr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:PicachvMessages.WildcardExpr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_WildcardExpr_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WildcardExpr& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};
// -------------------------------------------------------------------

class UnaryExpr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.UnaryExpr) */ {
 public:
  inline UnaryExpr() : UnaryExpr(nullptr) {}
  ~UnaryExpr() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnaryExpr(
      ::google::protobuf::internal::ConstantInitialized);

  inline UnaryExpr(const UnaryExpr& from) : UnaryExpr(nullptr, from) {}
  inline UnaryExpr(UnaryExpr&& from) noexcept
      : UnaryExpr(nullptr, std::move(from)) {}
  inline UnaryExpr& operator=(const UnaryExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaryExpr& operator=(UnaryExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnaryExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnaryExpr* internal_default_instance() {
    return reinterpret_cast<const UnaryExpr*>(
        &_UnaryExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(UnaryExpr& a, UnaryExpr& b) { a.Swap(&b); }
  inline void Swap(UnaryExpr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnaryExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnaryExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UnaryExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnaryExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnaryExpr& from) { UnaryExpr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnaryExpr* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.UnaryExpr"; }

 protected:
  explicit UnaryExpr(::google::protobuf::Arena* arena);
  UnaryExpr(::google::protobuf::Arena* arena, const UnaryExpr& from);
  UnaryExpr(::google::protobuf::Arena* arena, UnaryExpr&& from) noexcept
      : UnaryExpr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputUuidFieldNumber = 1,
    kOpFieldNumber = 2,
  };
  // bytes input_uuid = 1;
  void clear_input_uuid() ;
  const std::string& input_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_input_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_input_uuid();
  PROTOBUF_NODISCARD std::string* release_input_uuid();
  void set_allocated_input_uuid(std::string* value);

  private:
  const std::string& _internal_input_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_uuid(
      const std::string& value);
  std::string* _internal_mutable_input_uuid();

  public:
  // .PicachvMessages.UnaryOperator op = 2;
  void clear_op() ;
  ::PicachvMessages::UnaryOperator op() const;
  void set_op(::PicachvMessages::UnaryOperator value);

  private:
  ::PicachvMessages::UnaryOperator _internal_op() const;
  void _internal_set_op(::PicachvMessages::UnaryOperator value);

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.UnaryExpr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UnaryExpr_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UnaryExpr& from_msg);
    ::google::protobuf::internal::ArenaStringPtr input_uuid_;
    int op_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};
// -------------------------------------------------------------------

class LiteralExpr final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:PicachvMessages.LiteralExpr) */ {
 public:
  inline LiteralExpr() : LiteralExpr(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LiteralExpr(
      ::google::protobuf::internal::ConstantInitialized);

  inline LiteralExpr(const LiteralExpr& from) : LiteralExpr(nullptr, from) {}
  inline LiteralExpr(LiteralExpr&& from) noexcept
      : LiteralExpr(nullptr, std::move(from)) {}
  inline LiteralExpr& operator=(const LiteralExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiteralExpr& operator=(LiteralExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiteralExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiteralExpr* internal_default_instance() {
    return reinterpret_cast<const LiteralExpr*>(
        &_LiteralExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(LiteralExpr& a, LiteralExpr& b) { a.Swap(&b); }
  inline void Swap(LiteralExpr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiteralExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiteralExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<LiteralExpr>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LiteralExpr& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LiteralExpr& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.LiteralExpr"; }

 protected:
  explicit LiteralExpr(::google::protobuf::Arena* arena);
  LiteralExpr(::google::protobuf::Arena* arena, const LiteralExpr& from);
  LiteralExpr(::google::protobuf::Arena* arena, LiteralExpr&& from) noexcept
      : LiteralExpr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:PicachvMessages.LiteralExpr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LiteralExpr_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LiteralExpr& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};
// -------------------------------------------------------------------

class FilterExpr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.FilterExpr) */ {
 public:
  inline FilterExpr() : FilterExpr(nullptr) {}
  ~FilterExpr() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FilterExpr(
      ::google::protobuf::internal::ConstantInitialized);

  inline FilterExpr(const FilterExpr& from) : FilterExpr(nullptr, from) {}
  inline FilterExpr(FilterExpr&& from) noexcept
      : FilterExpr(nullptr, std::move(from)) {}
  inline FilterExpr& operator=(const FilterExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterExpr& operator=(FilterExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterExpr* internal_default_instance() {
    return reinterpret_cast<const FilterExpr*>(
        &_FilterExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(FilterExpr& a, FilterExpr& b) { a.Swap(&b); }
  inline void Swap(FilterExpr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilterExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FilterExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FilterExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FilterExpr& from) { FilterExpr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FilterExpr* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.FilterExpr"; }

 protected:
  explicit FilterExpr(::google::protobuf::Arena* arena);
  FilterExpr(::google::protobuf::Arena* arena, const FilterExpr& from);
  FilterExpr(::google::protobuf::Arena* arena, FilterExpr&& from) noexcept
      : FilterExpr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputUuidFieldNumber = 1,
    kFilterUuidFieldNumber = 2,
  };
  // bytes input_uuid = 1;
  void clear_input_uuid() ;
  const std::string& input_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_input_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_input_uuid();
  PROTOBUF_NODISCARD std::string* release_input_uuid();
  void set_allocated_input_uuid(std::string* value);

  private:
  const std::string& _internal_input_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_uuid(
      const std::string& value);
  std::string* _internal_mutable_input_uuid();

  public:
  // bytes filter_uuid = 2;
  void clear_filter_uuid() ;
  const std::string& filter_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filter_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_filter_uuid();
  PROTOBUF_NODISCARD std::string* release_filter_uuid();
  void set_allocated_filter_uuid(std::string* value);

  private:
  const std::string& _internal_filter_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_uuid(
      const std::string& value);
  std::string* _internal_mutable_filter_uuid();

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.FilterExpr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FilterExpr_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FilterExpr& from_msg);
    ::google::protobuf::internal::ArenaStringPtr input_uuid_;
    ::google::protobuf::internal::ArenaStringPtr filter_uuid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};
// -------------------------------------------------------------------

class ColumnExpr_ColumnNameSpecifier final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.ColumnExpr.ColumnNameSpecifier) */ {
 public:
  inline ColumnExpr_ColumnNameSpecifier() : ColumnExpr_ColumnNameSpecifier(nullptr) {}
  ~ColumnExpr_ColumnNameSpecifier() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColumnExpr_ColumnNameSpecifier(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColumnExpr_ColumnNameSpecifier(const ColumnExpr_ColumnNameSpecifier& from) : ColumnExpr_ColumnNameSpecifier(nullptr, from) {}
  inline ColumnExpr_ColumnNameSpecifier(ColumnExpr_ColumnNameSpecifier&& from) noexcept
      : ColumnExpr_ColumnNameSpecifier(nullptr, std::move(from)) {}
  inline ColumnExpr_ColumnNameSpecifier& operator=(const ColumnExpr_ColumnNameSpecifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnExpr_ColumnNameSpecifier& operator=(ColumnExpr_ColumnNameSpecifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnExpr_ColumnNameSpecifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnExpr_ColumnNameSpecifier* internal_default_instance() {
    return reinterpret_cast<const ColumnExpr_ColumnNameSpecifier*>(
        &_ColumnExpr_ColumnNameSpecifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ColumnExpr_ColumnNameSpecifier& a, ColumnExpr_ColumnNameSpecifier& b) { a.Swap(&b); }
  inline void Swap(ColumnExpr_ColumnNameSpecifier* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnExpr_ColumnNameSpecifier* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnExpr_ColumnNameSpecifier* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ColumnExpr_ColumnNameSpecifier>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColumnExpr_ColumnNameSpecifier& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ColumnExpr_ColumnNameSpecifier& from) { ColumnExpr_ColumnNameSpecifier::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ColumnExpr_ColumnNameSpecifier* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.ColumnExpr.ColumnNameSpecifier"; }

 protected:
  explicit ColumnExpr_ColumnNameSpecifier(::google::protobuf::Arena* arena);
  ColumnExpr_ColumnNameSpecifier(::google::protobuf::Arena* arena, const ColumnExpr_ColumnNameSpecifier& from);
  ColumnExpr_ColumnNameSpecifier(::google::protobuf::Arena* arena, ColumnExpr_ColumnNameSpecifier&& from) noexcept
      : ColumnExpr_ColumnNameSpecifier(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name() ;
  const std::string& column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* value);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.ColumnExpr.ColumnNameSpecifier)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      66, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ColumnExpr_ColumnNameSpecifier_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColumnExpr_ColumnNameSpecifier& from_msg);
    ::google::protobuf::internal::ArenaStringPtr column_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};
// -------------------------------------------------------------------

class ApplyExpr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.ApplyExpr) */ {
 public:
  inline ApplyExpr() : ApplyExpr(nullptr) {}
  ~ApplyExpr() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApplyExpr(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApplyExpr(const ApplyExpr& from) : ApplyExpr(nullptr, from) {}
  inline ApplyExpr(ApplyExpr&& from) noexcept
      : ApplyExpr(nullptr, std::move(from)) {}
  inline ApplyExpr& operator=(const ApplyExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyExpr& operator=(ApplyExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyExpr* internal_default_instance() {
    return reinterpret_cast<const ApplyExpr*>(
        &_ApplyExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ApplyExpr& a, ApplyExpr& b) { a.Swap(&b); }
  inline void Swap(ApplyExpr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ApplyExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApplyExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApplyExpr& from) { ApplyExpr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ApplyExpr* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.ApplyExpr"; }

 protected:
  explicit ApplyExpr(::google::protobuf::Arena* arena);
  ApplyExpr(::google::protobuf::Arena* arena, const ApplyExpr& from);
  ApplyExpr(::google::protobuf::Arena* arena, ApplyExpr&& from) noexcept
      : ApplyExpr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputUuidsFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // repeated bytes input_uuids = 1;
  int input_uuids_size() const;
  private:
  int _internal_input_uuids_size() const;

  public:
  void clear_input_uuids() ;
  const std::string& input_uuids(int index) const;
  std::string* mutable_input_uuids(int index);
  void set_input_uuids(int index, const std::string& value);
  void set_input_uuids(int index, std::string&& value);
  void set_input_uuids(int index, const char* value);
  void set_input_uuids(int index, const void* value, std::size_t size);
  void set_input_uuids(int index, absl::string_view value);
  std::string* add_input_uuids();
  void add_input_uuids(const std::string& value);
  void add_input_uuids(std::string&& value);
  void add_input_uuids(const char* value);
  void add_input_uuids(const void* value, std::size_t size);
  void add_input_uuids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& input_uuids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_input_uuids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_input_uuids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_input_uuids();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.ApplyExpr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ApplyExpr_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApplyExpr& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> input_uuids_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};
// -------------------------------------------------------------------

class AliasExpr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.AliasExpr) */ {
 public:
  inline AliasExpr() : AliasExpr(nullptr) {}
  ~AliasExpr() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AliasExpr(
      ::google::protobuf::internal::ConstantInitialized);

  inline AliasExpr(const AliasExpr& from) : AliasExpr(nullptr, from) {}
  inline AliasExpr(AliasExpr&& from) noexcept
      : AliasExpr(nullptr, std::move(from)) {}
  inline AliasExpr& operator=(const AliasExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline AliasExpr& operator=(AliasExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AliasExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const AliasExpr* internal_default_instance() {
    return reinterpret_cast<const AliasExpr*>(
        &_AliasExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(AliasExpr& a, AliasExpr& b) { a.Swap(&b); }
  inline void Swap(AliasExpr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AliasExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AliasExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AliasExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AliasExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AliasExpr& from) { AliasExpr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AliasExpr* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.AliasExpr"; }

 protected:
  explicit AliasExpr(::google::protobuf::Arena* arena);
  AliasExpr(::google::protobuf::Arena* arena, const AliasExpr& from);
  AliasExpr(::google::protobuf::Arena* arena, AliasExpr&& from) noexcept
      : AliasExpr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputUuidFieldNumber = 1,
    kAliasFieldNumber = 2,
  };
  // bytes input_uuid = 1;
  void clear_input_uuid() ;
  const std::string& input_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_input_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_input_uuid();
  PROTOBUF_NODISCARD std::string* release_input_uuid();
  void set_allocated_input_uuid(std::string* value);

  private:
  const std::string& _internal_input_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_uuid(
      const std::string& value);
  std::string* _internal_mutable_input_uuid();

  public:
  // string alias = 2;
  void clear_alias() ;
  const std::string& alias() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alias(Arg_&& arg, Args_... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* value);

  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(
      const std::string& value);
  std::string* _internal_mutable_alias();

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.AliasExpr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      39, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AliasExpr_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AliasExpr& from_msg);
    ::google::protobuf::internal::ArenaStringPtr input_uuid_;
    ::google::protobuf::internal::ArenaStringPtr alias_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};
// -------------------------------------------------------------------

class AggExpr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.AggExpr) */ {
 public:
  inline AggExpr() : AggExpr(nullptr) {}
  ~AggExpr() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AggExpr(
      ::google::protobuf::internal::ConstantInitialized);

  inline AggExpr(const AggExpr& from) : AggExpr(nullptr, from) {}
  inline AggExpr(AggExpr&& from) noexcept
      : AggExpr(nullptr, std::move(from)) {}
  inline AggExpr& operator=(const AggExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggExpr& operator=(AggExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggExpr* internal_default_instance() {
    return reinterpret_cast<const AggExpr*>(
        &_AggExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(AggExpr& a, AggExpr& b) { a.Swap(&b); }
  inline void Swap(AggExpr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AggExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AggExpr& from) { AggExpr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggExpr* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.AggExpr"; }

 protected:
  explicit AggExpr(::google::protobuf::Arena* arena);
  AggExpr(::google::protobuf::Arena* arena, const AggExpr& from);
  AggExpr(::google::protobuf::Arena* arena, AggExpr&& from) noexcept
      : AggExpr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputUuidFieldNumber = 1,
    kMethodFieldNumber = 2,
  };
  // bytes input_uuid = 1;
  void clear_input_uuid() ;
  const std::string& input_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_input_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_input_uuid();
  PROTOBUF_NODISCARD std::string* release_input_uuid();
  void set_allocated_input_uuid(std::string* value);

  private:
  const std::string& _internal_input_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_uuid(
      const std::string& value);
  std::string* _internal_mutable_input_uuid();

  public:
  // .PicachvMessages.GroupByMethod method = 2;
  void clear_method() ;
  ::PicachvMessages::GroupByMethod method() const;
  void set_method(::PicachvMessages::GroupByMethod value);

  private:
  ::PicachvMessages::GroupByMethod _internal_method() const;
  void _internal_set_method(::PicachvMessages::GroupByMethod value);

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.AggExpr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AggExpr_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AggExpr& from_msg);
    ::google::protobuf::internal::ArenaStringPtr input_uuid_;
    int method_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};
// -------------------------------------------------------------------

class ColumnExpr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.ColumnExpr) */ {
 public:
  inline ColumnExpr() : ColumnExpr(nullptr) {}
  ~ColumnExpr() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColumnExpr(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColumnExpr(const ColumnExpr& from) : ColumnExpr(nullptr, from) {}
  inline ColumnExpr(ColumnExpr&& from) noexcept
      : ColumnExpr(nullptr, std::move(from)) {}
  inline ColumnExpr& operator=(const ColumnExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnExpr& operator=(ColumnExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnExpr& default_instance() {
    return *internal_default_instance();
  }
  enum ColumnCase {
    kColumnId = 1,
    kColumnNameSpecifier = 2,
    COLUMN_NOT_SET = 0,
  };
  static inline const ColumnExpr* internal_default_instance() {
    return reinterpret_cast<const ColumnExpr*>(
        &_ColumnExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ColumnExpr& a, ColumnExpr& b) { a.Swap(&b); }
  inline void Swap(ColumnExpr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ColumnExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColumnExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ColumnExpr& from) { ColumnExpr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ColumnExpr* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.ColumnExpr"; }

 protected:
  explicit ColumnExpr(::google::protobuf::Arena* arena);
  ColumnExpr(::google::protobuf::Arena* arena, const ColumnExpr& from);
  ColumnExpr(::google::protobuf::Arena* arena, ColumnExpr&& from) noexcept
      : ColumnExpr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ColumnNameSpecifier = ColumnExpr_ColumnNameSpecifier;

  // accessors -------------------------------------------------------
  enum : int {
    kColumnIdFieldNumber = 1,
    kColumnNameSpecifierFieldNumber = 2,
  };
  // uint64 column_id = 1;
  bool has_column_id() const;
  void clear_column_id() ;
  ::uint64_t column_id() const;
  void set_column_id(::uint64_t value);

  private:
  ::uint64_t _internal_column_id() const;
  void _internal_set_column_id(::uint64_t value);

  public:
  // .PicachvMessages.ColumnExpr.ColumnNameSpecifier column_name_specifier = 2;
  bool has_column_name_specifier() const;
  private:
  bool _internal_has_column_name_specifier() const;

  public:
  void clear_column_name_specifier() ;
  const ::PicachvMessages::ColumnExpr_ColumnNameSpecifier& column_name_specifier() const;
  PROTOBUF_NODISCARD ::PicachvMessages::ColumnExpr_ColumnNameSpecifier* release_column_name_specifier();
  ::PicachvMessages::ColumnExpr_ColumnNameSpecifier* mutable_column_name_specifier();
  void set_allocated_column_name_specifier(::PicachvMessages::ColumnExpr_ColumnNameSpecifier* value);
  void unsafe_arena_set_allocated_column_name_specifier(::PicachvMessages::ColumnExpr_ColumnNameSpecifier* value);
  ::PicachvMessages::ColumnExpr_ColumnNameSpecifier* unsafe_arena_release_column_name_specifier();

  private:
  const ::PicachvMessages::ColumnExpr_ColumnNameSpecifier& _internal_column_name_specifier() const;
  ::PicachvMessages::ColumnExpr_ColumnNameSpecifier* _internal_mutable_column_name_specifier();

  public:
  void clear_column();
  ColumnCase column_case() const;
  // @@protoc_insertion_point(class_scope:PicachvMessages.ColumnExpr)
 private:
  class _Internal;
  void set_has_column_id();
  void set_has_column_name_specifier();
  inline bool has_column() const;
  inline void clear_has_column();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ColumnExpr_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColumnExpr& from_msg);
    union ColumnUnion {
      constexpr ColumnUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t column_id_;
      ::PicachvMessages::ColumnExpr_ColumnNameSpecifier* column_name_specifier_;
    } column_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};
// -------------------------------------------------------------------

class BinaryExpr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.BinaryExpr) */ {
 public:
  inline BinaryExpr() : BinaryExpr(nullptr) {}
  ~BinaryExpr() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryExpr(
      ::google::protobuf::internal::ConstantInitialized);

  inline BinaryExpr(const BinaryExpr& from) : BinaryExpr(nullptr, from) {}
  inline BinaryExpr(BinaryExpr&& from) noexcept
      : BinaryExpr(nullptr, std::move(from)) {}
  inline BinaryExpr& operator=(const BinaryExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryExpr& operator=(BinaryExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryExpr*>(
        &_BinaryExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(BinaryExpr& a, BinaryExpr& b) { a.Swap(&b); }
  inline void Swap(BinaryExpr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BinaryExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BinaryExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BinaryExpr& from) { BinaryExpr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BinaryExpr* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.BinaryExpr"; }

 protected:
  explicit BinaryExpr(::google::protobuf::Arena* arena);
  BinaryExpr(::google::protobuf::Arena* arena, const BinaryExpr& from);
  BinaryExpr(::google::protobuf::Arena* arena, BinaryExpr&& from) noexcept
      : BinaryExpr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLeftUuidFieldNumber = 1,
    kRightUuidFieldNumber = 2,
    kOpFieldNumber = 3,
  };
  // bytes left_uuid = 1;
  void clear_left_uuid() ;
  const std::string& left_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_left_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_left_uuid();
  PROTOBUF_NODISCARD std::string* release_left_uuid();
  void set_allocated_left_uuid(std::string* value);

  private:
  const std::string& _internal_left_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_left_uuid(
      const std::string& value);
  std::string* _internal_mutable_left_uuid();

  public:
  // bytes right_uuid = 2;
  void clear_right_uuid() ;
  const std::string& right_uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_right_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_right_uuid();
  PROTOBUF_NODISCARD std::string* release_right_uuid();
  void set_allocated_right_uuid(std::string* value);

  private:
  const std::string& _internal_right_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_right_uuid(
      const std::string& value);
  std::string* _internal_mutable_right_uuid();

  public:
  // .PicachvMessages.BinaryOperator op = 3;
  bool has_op() const;
  void clear_op() ;
  const ::PicachvMessages::BinaryOperator& op() const;
  PROTOBUF_NODISCARD ::PicachvMessages::BinaryOperator* release_op();
  ::PicachvMessages::BinaryOperator* mutable_op();
  void set_allocated_op(::PicachvMessages::BinaryOperator* value);
  void unsafe_arena_set_allocated_op(::PicachvMessages::BinaryOperator* value);
  ::PicachvMessages::BinaryOperator* unsafe_arena_release_op();

  private:
  const ::PicachvMessages::BinaryOperator& _internal_op() const;
  ::PicachvMessages::BinaryOperator* _internal_mutable_op();

  public:
  // @@protoc_insertion_point(class_scope:PicachvMessages.BinaryExpr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_BinaryExpr_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BinaryExpr& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr left_uuid_;
    ::google::protobuf::internal::ArenaStringPtr right_uuid_;
    ::PicachvMessages::BinaryOperator* op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};
// -------------------------------------------------------------------

class ExprArgument final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PicachvMessages.ExprArgument) */ {
 public:
  inline ExprArgument() : ExprArgument(nullptr) {}
  ~ExprArgument() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExprArgument(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExprArgument(const ExprArgument& from) : ExprArgument(nullptr, from) {}
  inline ExprArgument(ExprArgument&& from) noexcept
      : ExprArgument(nullptr, std::move(from)) {}
  inline ExprArgument& operator=(const ExprArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExprArgument& operator=(ExprArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExprArgument& default_instance() {
    return *internal_default_instance();
  }
  enum ArgumentCase {
    kAgg = 1,
    kColumn = 2,
    kAlias = 3,
    kWildcard = 4,
    kFilter = 5,
    kBinary = 6,
    kUnary = 7,
    kLiteral = 8,
    kApply = 9,
    ARGUMENT_NOT_SET = 0,
  };
  static inline const ExprArgument* internal_default_instance() {
    return reinterpret_cast<const ExprArgument*>(
        &_ExprArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ExprArgument& a, ExprArgument& b) { a.Swap(&b); }
  inline void Swap(ExprArgument* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExprArgument* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExprArgument* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExprArgument>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExprArgument& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExprArgument& from) { ExprArgument::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExprArgument* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PicachvMessages.ExprArgument"; }

 protected:
  explicit ExprArgument(::google::protobuf::Arena* arena);
  ExprArgument(::google::protobuf::Arena* arena, const ExprArgument& from);
  ExprArgument(::google::protobuf::Arena* arena, ExprArgument&& from) noexcept
      : ExprArgument(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAggFieldNumber = 1,
    kColumnFieldNumber = 2,
    kAliasFieldNumber = 3,
    kWildcardFieldNumber = 4,
    kFilterFieldNumber = 5,
    kBinaryFieldNumber = 6,
    kUnaryFieldNumber = 7,
    kLiteralFieldNumber = 8,
    kApplyFieldNumber = 9,
  };
  // .PicachvMessages.AggExpr agg = 1;
  bool has_agg() const;
  private:
  bool _internal_has_agg() const;

  public:
  void clear_agg() ;
  const ::PicachvMessages::AggExpr& agg() const;
  PROTOBUF_NODISCARD ::PicachvMessages::AggExpr* release_agg();
  ::PicachvMessages::AggExpr* mutable_agg();
  void set_allocated_agg(::PicachvMessages::AggExpr* value);
  void unsafe_arena_set_allocated_agg(::PicachvMessages::AggExpr* value);
  ::PicachvMessages::AggExpr* unsafe_arena_release_agg();

  private:
  const ::PicachvMessages::AggExpr& _internal_agg() const;
  ::PicachvMessages::AggExpr* _internal_mutable_agg();

  public:
  // .PicachvMessages.ColumnExpr column = 2;
  bool has_column() const;
  private:
  bool _internal_has_column() const;

  public:
  void clear_column() ;
  const ::PicachvMessages::ColumnExpr& column() const;
  PROTOBUF_NODISCARD ::PicachvMessages::ColumnExpr* release_column();
  ::PicachvMessages::ColumnExpr* mutable_column();
  void set_allocated_column(::PicachvMessages::ColumnExpr* value);
  void unsafe_arena_set_allocated_column(::PicachvMessages::ColumnExpr* value);
  ::PicachvMessages::ColumnExpr* unsafe_arena_release_column();

  private:
  const ::PicachvMessages::ColumnExpr& _internal_column() const;
  ::PicachvMessages::ColumnExpr* _internal_mutable_column();

  public:
  // .PicachvMessages.AliasExpr alias = 3;
  bool has_alias() const;
  private:
  bool _internal_has_alias() const;

  public:
  void clear_alias() ;
  const ::PicachvMessages::AliasExpr& alias() const;
  PROTOBUF_NODISCARD ::PicachvMessages::AliasExpr* release_alias();
  ::PicachvMessages::AliasExpr* mutable_alias();
  void set_allocated_alias(::PicachvMessages::AliasExpr* value);
  void unsafe_arena_set_allocated_alias(::PicachvMessages::AliasExpr* value);
  ::PicachvMessages::AliasExpr* unsafe_arena_release_alias();

  private:
  const ::PicachvMessages::AliasExpr& _internal_alias() const;
  ::PicachvMessages::AliasExpr* _internal_mutable_alias();

  public:
  // .PicachvMessages.WildcardExpr wildcard = 4;
  bool has_wildcard() const;
  private:
  bool _internal_has_wildcard() const;

  public:
  void clear_wildcard() ;
  const ::PicachvMessages::WildcardExpr& wildcard() const;
  PROTOBUF_NODISCARD ::PicachvMessages::WildcardExpr* release_wildcard();
  ::PicachvMessages::WildcardExpr* mutable_wildcard();
  void set_allocated_wildcard(::PicachvMessages::WildcardExpr* value);
  void unsafe_arena_set_allocated_wildcard(::PicachvMessages::WildcardExpr* value);
  ::PicachvMessages::WildcardExpr* unsafe_arena_release_wildcard();

  private:
  const ::PicachvMessages::WildcardExpr& _internal_wildcard() const;
  ::PicachvMessages::WildcardExpr* _internal_mutable_wildcard();

  public:
  // .PicachvMessages.FilterExpr filter = 5;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;

  public:
  void clear_filter() ;
  const ::PicachvMessages::FilterExpr& filter() const;
  PROTOBUF_NODISCARD ::PicachvMessages::FilterExpr* release_filter();
  ::PicachvMessages::FilterExpr* mutable_filter();
  void set_allocated_filter(::PicachvMessages::FilterExpr* value);
  void unsafe_arena_set_allocated_filter(::PicachvMessages::FilterExpr* value);
  ::PicachvMessages::FilterExpr* unsafe_arena_release_filter();

  private:
  const ::PicachvMessages::FilterExpr& _internal_filter() const;
  ::PicachvMessages::FilterExpr* _internal_mutable_filter();

  public:
  // .PicachvMessages.BinaryExpr binary = 6;
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;

  public:
  void clear_binary() ;
  const ::PicachvMessages::BinaryExpr& binary() const;
  PROTOBUF_NODISCARD ::PicachvMessages::BinaryExpr* release_binary();
  ::PicachvMessages::BinaryExpr* mutable_binary();
  void set_allocated_binary(::PicachvMessages::BinaryExpr* value);
  void unsafe_arena_set_allocated_binary(::PicachvMessages::BinaryExpr* value);
  ::PicachvMessages::BinaryExpr* unsafe_arena_release_binary();

  private:
  const ::PicachvMessages::BinaryExpr& _internal_binary() const;
  ::PicachvMessages::BinaryExpr* _internal_mutable_binary();

  public:
  // .PicachvMessages.UnaryExpr unary = 7;
  bool has_unary() const;
  private:
  bool _internal_has_unary() const;

  public:
  void clear_unary() ;
  const ::PicachvMessages::UnaryExpr& unary() const;
  PROTOBUF_NODISCARD ::PicachvMessages::UnaryExpr* release_unary();
  ::PicachvMessages::UnaryExpr* mutable_unary();
  void set_allocated_unary(::PicachvMessages::UnaryExpr* value);
  void unsafe_arena_set_allocated_unary(::PicachvMessages::UnaryExpr* value);
  ::PicachvMessages::UnaryExpr* unsafe_arena_release_unary();

  private:
  const ::PicachvMessages::UnaryExpr& _internal_unary() const;
  ::PicachvMessages::UnaryExpr* _internal_mutable_unary();

  public:
  // .PicachvMessages.LiteralExpr literal = 8;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;

  public:
  void clear_literal() ;
  const ::PicachvMessages::LiteralExpr& literal() const;
  PROTOBUF_NODISCARD ::PicachvMessages::LiteralExpr* release_literal();
  ::PicachvMessages::LiteralExpr* mutable_literal();
  void set_allocated_literal(::PicachvMessages::LiteralExpr* value);
  void unsafe_arena_set_allocated_literal(::PicachvMessages::LiteralExpr* value);
  ::PicachvMessages::LiteralExpr* unsafe_arena_release_literal();

  private:
  const ::PicachvMessages::LiteralExpr& _internal_literal() const;
  ::PicachvMessages::LiteralExpr* _internal_mutable_literal();

  public:
  // .PicachvMessages.ApplyExpr apply = 9;
  bool has_apply() const;
  private:
  bool _internal_has_apply() const;

  public:
  void clear_apply() ;
  const ::PicachvMessages::ApplyExpr& apply() const;
  PROTOBUF_NODISCARD ::PicachvMessages::ApplyExpr* release_apply();
  ::PicachvMessages::ApplyExpr* mutable_apply();
  void set_allocated_apply(::PicachvMessages::ApplyExpr* value);
  void unsafe_arena_set_allocated_apply(::PicachvMessages::ApplyExpr* value);
  ::PicachvMessages::ApplyExpr* unsafe_arena_release_apply();

  private:
  const ::PicachvMessages::ApplyExpr& _internal_apply() const;
  ::PicachvMessages::ApplyExpr* _internal_mutable_apply();

  public:
  void clear_argument();
  ArgumentCase argument_case() const;
  // @@protoc_insertion_point(class_scope:PicachvMessages.ExprArgument)
 private:
  class _Internal;
  void set_has_agg();
  void set_has_column();
  void set_has_alias();
  void set_has_wildcard();
  void set_has_filter();
  void set_has_binary();
  void set_has_unary();
  void set_has_literal();
  void set_has_apply();
  inline bool has_argument() const;
  inline void clear_has_argument();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 9, 9,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ExprArgument_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExprArgument& from_msg);
    union ArgumentUnion {
      constexpr ArgumentUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::PicachvMessages::AggExpr* agg_;
      ::PicachvMessages::ColumnExpr* column_;
      ::PicachvMessages::AliasExpr* alias_;
      ::PicachvMessages::WildcardExpr* wildcard_;
      ::PicachvMessages::FilterExpr* filter_;
      ::PicachvMessages::BinaryExpr* binary_;
      ::PicachvMessages::UnaryExpr* unary_;
      ::PicachvMessages::LiteralExpr* literal_;
      ::PicachvMessages::ApplyExpr* apply_;
    } argument_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_expr_5fargs_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AggExpr

// bytes input_uuid = 1;
inline void AggExpr::clear_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.ClearToEmpty();
}
inline const std::string& AggExpr::input_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggExpr.input_uuid)
  return _internal_input_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AggExpr::set_input_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.AggExpr.input_uuid)
}
inline std::string* AggExpr::mutable_input_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_input_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AggExpr.input_uuid)
  return _s;
}
inline const std::string& AggExpr::_internal_input_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_uuid_.Get();
}
inline void AggExpr::_internal_set_input_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.Set(value, GetArena());
}
inline std::string* AggExpr::_internal_mutable_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.input_uuid_.Mutable( GetArena());
}
inline std::string* AggExpr::release_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.AggExpr.input_uuid)
  return _impl_.input_uuid_.Release();
}
inline void AggExpr::set_allocated_input_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.input_uuid_.IsDefault()) {
          _impl_.input_uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.AggExpr.input_uuid)
}

// .PicachvMessages.GroupByMethod method = 2;
inline void AggExpr::clear_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_ = 0;
}
inline ::PicachvMessages::GroupByMethod AggExpr::method() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.AggExpr.method)
  return _internal_method();
}
inline void AggExpr::set_method(::PicachvMessages::GroupByMethod value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.AggExpr.method)
}
inline ::PicachvMessages::GroupByMethod AggExpr::_internal_method() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::PicachvMessages::GroupByMethod>(_impl_.method_);
}
inline void AggExpr::_internal_set_method(::PicachvMessages::GroupByMethod value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_ = value;
}

// -------------------------------------------------------------------

// ColumnExpr_ColumnNameSpecifier

// string column_name = 1;
inline void ColumnExpr_ColumnNameSpecifier::clear_column_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& ColumnExpr_ColumnNameSpecifier::column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ColumnExpr.ColumnNameSpecifier.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ColumnExpr_ColumnNameSpecifier::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.ColumnExpr.ColumnNameSpecifier.column_name)
}
inline std::string* ColumnExpr_ColumnNameSpecifier::mutable_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ColumnExpr.ColumnNameSpecifier.column_name)
  return _s;
}
inline const std::string& ColumnExpr_ColumnNameSpecifier::_internal_column_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.column_name_.Get();
}
inline void ColumnExpr_ColumnNameSpecifier::_internal_set_column_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_name_.Set(value, GetArena());
}
inline std::string* ColumnExpr_ColumnNameSpecifier::_internal_mutable_column_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.column_name_.Mutable( GetArena());
}
inline std::string* ColumnExpr_ColumnNameSpecifier::release_column_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.ColumnExpr.ColumnNameSpecifier.column_name)
  return _impl_.column_name_.Release();
}
inline void ColumnExpr_ColumnNameSpecifier::set_allocated_column_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.ColumnExpr.ColumnNameSpecifier.column_name)
}

// -------------------------------------------------------------------

// ColumnExpr

// uint64 column_id = 1;
inline bool ColumnExpr::has_column_id() const {
  return column_case() == kColumnId;
}
inline void ColumnExpr::set_has_column_id() {
  _impl_._oneof_case_[0] = kColumnId;
}
inline void ColumnExpr::clear_column_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (column_case() == kColumnId) {
    _impl_.column_.column_id_ = ::uint64_t{0u};
    clear_has_column();
  }
}
inline ::uint64_t ColumnExpr::column_id() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.ColumnExpr.column_id)
  return _internal_column_id();
}
inline void ColumnExpr::set_column_id(::uint64_t value) {
  if (column_case() != kColumnId) {
    clear_column();
    set_has_column_id();
  }
  _impl_.column_.column_id_ = value;
  // @@protoc_insertion_point(field_set:PicachvMessages.ColumnExpr.column_id)
}
inline ::uint64_t ColumnExpr::_internal_column_id() const {
  if (column_case() == kColumnId) {
    return _impl_.column_.column_id_;
  }
  return ::uint64_t{0u};
}

// .PicachvMessages.ColumnExpr.ColumnNameSpecifier column_name_specifier = 2;
inline bool ColumnExpr::has_column_name_specifier() const {
  return column_case() == kColumnNameSpecifier;
}
inline bool ColumnExpr::_internal_has_column_name_specifier() const {
  return column_case() == kColumnNameSpecifier;
}
inline void ColumnExpr::set_has_column_name_specifier() {
  _impl_._oneof_case_[0] = kColumnNameSpecifier;
}
inline void ColumnExpr::clear_column_name_specifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (column_case() == kColumnNameSpecifier) {
    if (GetArena() == nullptr) {
      delete _impl_.column_.column_name_specifier_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.column_.column_name_specifier_);
    }
    clear_has_column();
  }
}
inline ::PicachvMessages::ColumnExpr_ColumnNameSpecifier* ColumnExpr::release_column_name_specifier() {
  // @@protoc_insertion_point(field_release:PicachvMessages.ColumnExpr.column_name_specifier)
  if (column_case() == kColumnNameSpecifier) {
    clear_has_column();
    auto* temp = _impl_.column_.column_name_specifier_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.column_.column_name_specifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::ColumnExpr_ColumnNameSpecifier& ColumnExpr::_internal_column_name_specifier() const {
  return column_case() == kColumnNameSpecifier ? *_impl_.column_.column_name_specifier_ : reinterpret_cast<::PicachvMessages::ColumnExpr_ColumnNameSpecifier&>(::PicachvMessages::_ColumnExpr_ColumnNameSpecifier_default_instance_);
}
inline const ::PicachvMessages::ColumnExpr_ColumnNameSpecifier& ColumnExpr::column_name_specifier() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ColumnExpr.column_name_specifier)
  return _internal_column_name_specifier();
}
inline ::PicachvMessages::ColumnExpr_ColumnNameSpecifier* ColumnExpr::unsafe_arena_release_column_name_specifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.ColumnExpr.column_name_specifier)
  if (column_case() == kColumnNameSpecifier) {
    clear_has_column();
    auto* temp = _impl_.column_.column_name_specifier_;
    _impl_.column_.column_name_specifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ColumnExpr::unsafe_arena_set_allocated_column_name_specifier(::PicachvMessages::ColumnExpr_ColumnNameSpecifier* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_column();
  if (value) {
    set_has_column_name_specifier();
    _impl_.column_.column_name_specifier_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.ColumnExpr.column_name_specifier)
}
inline ::PicachvMessages::ColumnExpr_ColumnNameSpecifier* ColumnExpr::_internal_mutable_column_name_specifier() {
  if (column_case() != kColumnNameSpecifier) {
    clear_column();
    set_has_column_name_specifier();
    _impl_.column_.column_name_specifier_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::ColumnExpr_ColumnNameSpecifier>(GetArena());
  }
  return _impl_.column_.column_name_specifier_;
}
inline ::PicachvMessages::ColumnExpr_ColumnNameSpecifier* ColumnExpr::mutable_column_name_specifier() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::ColumnExpr_ColumnNameSpecifier* _msg = _internal_mutable_column_name_specifier();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ColumnExpr.column_name_specifier)
  return _msg;
}

inline bool ColumnExpr::has_column() const {
  return column_case() != COLUMN_NOT_SET;
}
inline void ColumnExpr::clear_has_column() {
  _impl_._oneof_case_[0] = COLUMN_NOT_SET;
}
inline ColumnExpr::ColumnCase ColumnExpr::column_case() const {
  return ColumnExpr::ColumnCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AliasExpr

// bytes input_uuid = 1;
inline void AliasExpr::clear_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.ClearToEmpty();
}
inline const std::string& AliasExpr::input_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.AliasExpr.input_uuid)
  return _internal_input_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AliasExpr::set_input_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.AliasExpr.input_uuid)
}
inline std::string* AliasExpr::mutable_input_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_input_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AliasExpr.input_uuid)
  return _s;
}
inline const std::string& AliasExpr::_internal_input_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_uuid_.Get();
}
inline void AliasExpr::_internal_set_input_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.Set(value, GetArena());
}
inline std::string* AliasExpr::_internal_mutable_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.input_uuid_.Mutable( GetArena());
}
inline std::string* AliasExpr::release_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.AliasExpr.input_uuid)
  return _impl_.input_uuid_.Release();
}
inline void AliasExpr::set_allocated_input_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.input_uuid_.IsDefault()) {
          _impl_.input_uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.AliasExpr.input_uuid)
}

// string alias = 2;
inline void AliasExpr::clear_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.ClearToEmpty();
}
inline const std::string& AliasExpr::alias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.AliasExpr.alias)
  return _internal_alias();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AliasExpr::set_alias(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.AliasExpr.alias)
}
inline std::string* AliasExpr::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.AliasExpr.alias)
  return _s;
}
inline const std::string& AliasExpr::_internal_alias() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alias_.Get();
}
inline void AliasExpr::_internal_set_alias(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.Set(value, GetArena());
}
inline std::string* AliasExpr::_internal_mutable_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alias_.Mutable( GetArena());
}
inline std::string* AliasExpr::release_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.AliasExpr.alias)
  return _impl_.alias_.Release();
}
inline void AliasExpr::set_allocated_alias(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alias_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.alias_.IsDefault()) {
          _impl_.alias_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.AliasExpr.alias)
}

// -------------------------------------------------------------------

// WildcardExpr

// -------------------------------------------------------------------

// LiteralExpr

// -------------------------------------------------------------------

// FilterExpr

// bytes input_uuid = 1;
inline void FilterExpr::clear_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.ClearToEmpty();
}
inline const std::string& FilterExpr::input_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.FilterExpr.input_uuid)
  return _internal_input_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FilterExpr::set_input_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.FilterExpr.input_uuid)
}
inline std::string* FilterExpr::mutable_input_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_input_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.FilterExpr.input_uuid)
  return _s;
}
inline const std::string& FilterExpr::_internal_input_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_uuid_.Get();
}
inline void FilterExpr::_internal_set_input_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.Set(value, GetArena());
}
inline std::string* FilterExpr::_internal_mutable_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.input_uuid_.Mutable( GetArena());
}
inline std::string* FilterExpr::release_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.FilterExpr.input_uuid)
  return _impl_.input_uuid_.Release();
}
inline void FilterExpr::set_allocated_input_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.input_uuid_.IsDefault()) {
          _impl_.input_uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.FilterExpr.input_uuid)
}

// bytes filter_uuid = 2;
inline void FilterExpr::clear_filter_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_uuid_.ClearToEmpty();
}
inline const std::string& FilterExpr::filter_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.FilterExpr.filter_uuid)
  return _internal_filter_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FilterExpr::set_filter_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.FilterExpr.filter_uuid)
}
inline std::string* FilterExpr::mutable_filter_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filter_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.FilterExpr.filter_uuid)
  return _s;
}
inline const std::string& FilterExpr::_internal_filter_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filter_uuid_.Get();
}
inline void FilterExpr::_internal_set_filter_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_uuid_.Set(value, GetArena());
}
inline std::string* FilterExpr::_internal_mutable_filter_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.filter_uuid_.Mutable( GetArena());
}
inline std::string* FilterExpr::release_filter_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.FilterExpr.filter_uuid)
  return _impl_.filter_uuid_.Release();
}
inline void FilterExpr::set_allocated_filter_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filter_uuid_.IsDefault()) {
          _impl_.filter_uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.FilterExpr.filter_uuid)
}

// -------------------------------------------------------------------

// BinaryExpr

// bytes left_uuid = 1;
inline void BinaryExpr::clear_left_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_uuid_.ClearToEmpty();
}
inline const std::string& BinaryExpr::left_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.BinaryExpr.left_uuid)
  return _internal_left_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryExpr::set_left_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.BinaryExpr.left_uuid)
}
inline std::string* BinaryExpr::mutable_left_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_left_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.BinaryExpr.left_uuid)
  return _s;
}
inline const std::string& BinaryExpr::_internal_left_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.left_uuid_.Get();
}
inline void BinaryExpr::_internal_set_left_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_uuid_.Set(value, GetArena());
}
inline std::string* BinaryExpr::_internal_mutable_left_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.left_uuid_.Mutable( GetArena());
}
inline std::string* BinaryExpr::release_left_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.BinaryExpr.left_uuid)
  return _impl_.left_uuid_.Release();
}
inline void BinaryExpr::set_allocated_left_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.left_uuid_.IsDefault()) {
          _impl_.left_uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.BinaryExpr.left_uuid)
}

// bytes right_uuid = 2;
inline void BinaryExpr::clear_right_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_uuid_.ClearToEmpty();
}
inline const std::string& BinaryExpr::right_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.BinaryExpr.right_uuid)
  return _internal_right_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryExpr::set_right_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.BinaryExpr.right_uuid)
}
inline std::string* BinaryExpr::mutable_right_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_right_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.BinaryExpr.right_uuid)
  return _s;
}
inline const std::string& BinaryExpr::_internal_right_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.right_uuid_.Get();
}
inline void BinaryExpr::_internal_set_right_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_uuid_.Set(value, GetArena());
}
inline std::string* BinaryExpr::_internal_mutable_right_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.right_uuid_.Mutable( GetArena());
}
inline std::string* BinaryExpr::release_right_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.BinaryExpr.right_uuid)
  return _impl_.right_uuid_.Release();
}
inline void BinaryExpr::set_allocated_right_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.right_uuid_.IsDefault()) {
          _impl_.right_uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.BinaryExpr.right_uuid)
}

// .PicachvMessages.BinaryOperator op = 3;
inline bool BinaryExpr::has_op() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.op_ != nullptr);
  return value;
}
inline const ::PicachvMessages::BinaryOperator& BinaryExpr::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::PicachvMessages::BinaryOperator* p = _impl_.op_;
  return p != nullptr ? *p : reinterpret_cast<const ::PicachvMessages::BinaryOperator&>(::PicachvMessages::_BinaryOperator_default_instance_);
}
inline const ::PicachvMessages::BinaryOperator& BinaryExpr::op() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.BinaryExpr.op)
  return _internal_op();
}
inline void BinaryExpr::unsafe_arena_set_allocated_op(::PicachvMessages::BinaryOperator* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.op_);
  }
  _impl_.op_ = reinterpret_cast<::PicachvMessages::BinaryOperator*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.BinaryExpr.op)
}
inline ::PicachvMessages::BinaryOperator* BinaryExpr::release_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PicachvMessages::BinaryOperator* released = _impl_.op_;
  _impl_.op_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::PicachvMessages::BinaryOperator* BinaryExpr::unsafe_arena_release_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.BinaryExpr.op)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PicachvMessages::BinaryOperator* temp = _impl_.op_;
  _impl_.op_ = nullptr;
  return temp;
}
inline ::PicachvMessages::BinaryOperator* BinaryExpr::_internal_mutable_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::BinaryOperator>(GetArena());
    _impl_.op_ = reinterpret_cast<::PicachvMessages::BinaryOperator*>(p);
  }
  return _impl_.op_;
}
inline ::PicachvMessages::BinaryOperator* BinaryExpr::mutable_op() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::PicachvMessages::BinaryOperator* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.BinaryExpr.op)
  return _msg;
}
inline void BinaryExpr::set_allocated_op(::PicachvMessages::BinaryOperator* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.op_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.op_ = reinterpret_cast<::PicachvMessages::BinaryOperator*>(value);
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.BinaryExpr.op)
}

// -------------------------------------------------------------------

// UnaryExpr

// bytes input_uuid = 1;
inline void UnaryExpr::clear_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.ClearToEmpty();
}
inline const std::string& UnaryExpr::input_uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.UnaryExpr.input_uuid)
  return _internal_input_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnaryExpr::set_input_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.UnaryExpr.input_uuid)
}
inline std::string* UnaryExpr::mutable_input_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_input_uuid();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.UnaryExpr.input_uuid)
  return _s;
}
inline const std::string& UnaryExpr::_internal_input_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_uuid_.Get();
}
inline void UnaryExpr::_internal_set_input_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.Set(value, GetArena());
}
inline std::string* UnaryExpr::_internal_mutable_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.input_uuid_.Mutable( GetArena());
}
inline std::string* UnaryExpr::release_input_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.UnaryExpr.input_uuid)
  return _impl_.input_uuid_.Release();
}
inline void UnaryExpr::set_allocated_input_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.input_uuid_.IsDefault()) {
          _impl_.input_uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.UnaryExpr.input_uuid)
}

// .PicachvMessages.UnaryOperator op = 2;
inline void UnaryExpr::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
}
inline ::PicachvMessages::UnaryOperator UnaryExpr::op() const {
  // @@protoc_insertion_point(field_get:PicachvMessages.UnaryExpr.op)
  return _internal_op();
}
inline void UnaryExpr::set_op(::PicachvMessages::UnaryOperator value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.UnaryExpr.op)
}
inline ::PicachvMessages::UnaryOperator UnaryExpr::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::PicachvMessages::UnaryOperator>(_impl_.op_);
}
inline void UnaryExpr::_internal_set_op(::PicachvMessages::UnaryOperator value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = value;
}

// -------------------------------------------------------------------

// ApplyExpr

// repeated bytes input_uuids = 1;
inline int ApplyExpr::_internal_input_uuids_size() const {
  return _internal_input_uuids().size();
}
inline int ApplyExpr::input_uuids_size() const {
  return _internal_input_uuids_size();
}
inline void ApplyExpr::clear_input_uuids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_uuids_.Clear();
}
inline std::string* ApplyExpr::add_input_uuids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_input_uuids()->Add();
  // @@protoc_insertion_point(field_add_mutable:PicachvMessages.ApplyExpr.input_uuids)
  return _s;
}
inline const std::string& ApplyExpr::input_uuids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ApplyExpr.input_uuids)
  return _internal_input_uuids().Get(index);
}
inline std::string* ApplyExpr::mutable_input_uuids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ApplyExpr.input_uuids)
  return _internal_mutable_input_uuids()->Mutable(index);
}
inline void ApplyExpr::set_input_uuids(int index, const std::string& value) {
  _internal_mutable_input_uuids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PicachvMessages.ApplyExpr.input_uuids)
}
inline void ApplyExpr::set_input_uuids(int index, std::string&& value) {
  _internal_mutable_input_uuids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PicachvMessages.ApplyExpr.input_uuids)
}
inline void ApplyExpr::set_input_uuids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_input_uuids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PicachvMessages.ApplyExpr.input_uuids)
}
inline void ApplyExpr::set_input_uuids(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_input_uuids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PicachvMessages.ApplyExpr.input_uuids)
}
inline void ApplyExpr::set_input_uuids(int index, absl::string_view value) {
  _internal_mutable_input_uuids()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:PicachvMessages.ApplyExpr.input_uuids)
}
inline void ApplyExpr::add_input_uuids(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_input_uuids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:PicachvMessages.ApplyExpr.input_uuids)
}
inline void ApplyExpr::add_input_uuids(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_input_uuids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:PicachvMessages.ApplyExpr.input_uuids)
}
inline void ApplyExpr::add_input_uuids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_input_uuids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PicachvMessages.ApplyExpr.input_uuids)
}
inline void ApplyExpr::add_input_uuids(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_input_uuids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PicachvMessages.ApplyExpr.input_uuids)
}
inline void ApplyExpr::add_input_uuids(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_input_uuids()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:PicachvMessages.ApplyExpr.input_uuids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ApplyExpr::input_uuids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:PicachvMessages.ApplyExpr.input_uuids)
  return _internal_input_uuids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ApplyExpr::mutable_input_uuids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:PicachvMessages.ApplyExpr.input_uuids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_input_uuids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ApplyExpr::_internal_input_uuids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_uuids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ApplyExpr::_internal_mutable_input_uuids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.input_uuids_;
}

// string name = 2;
inline void ApplyExpr::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ApplyExpr::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ApplyExpr.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ApplyExpr::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PicachvMessages.ApplyExpr.name)
}
inline std::string* ApplyExpr::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ApplyExpr.name)
  return _s;
}
inline const std::string& ApplyExpr::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ApplyExpr::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ApplyExpr::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ApplyExpr::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PicachvMessages.ApplyExpr.name)
  return _impl_.name_.Release();
}
inline void ApplyExpr::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PicachvMessages.ApplyExpr.name)
}

// -------------------------------------------------------------------

// ExprArgument

// .PicachvMessages.AggExpr agg = 1;
inline bool ExprArgument::has_agg() const {
  return argument_case() == kAgg;
}
inline bool ExprArgument::_internal_has_agg() const {
  return argument_case() == kAgg;
}
inline void ExprArgument::set_has_agg() {
  _impl_._oneof_case_[0] = kAgg;
}
inline void ExprArgument::clear_agg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kAgg) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.agg_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.agg_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::AggExpr* ExprArgument::release_agg() {
  // @@protoc_insertion_point(field_release:PicachvMessages.ExprArgument.agg)
  if (argument_case() == kAgg) {
    clear_has_argument();
    auto* temp = _impl_.argument_.agg_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.agg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::AggExpr& ExprArgument::_internal_agg() const {
  return argument_case() == kAgg ? *_impl_.argument_.agg_ : reinterpret_cast<::PicachvMessages::AggExpr&>(::PicachvMessages::_AggExpr_default_instance_);
}
inline const ::PicachvMessages::AggExpr& ExprArgument::agg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ExprArgument.agg)
  return _internal_agg();
}
inline ::PicachvMessages::AggExpr* ExprArgument::unsafe_arena_release_agg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.ExprArgument.agg)
  if (argument_case() == kAgg) {
    clear_has_argument();
    auto* temp = _impl_.argument_.agg_;
    _impl_.argument_.agg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExprArgument::unsafe_arena_set_allocated_agg(::PicachvMessages::AggExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_agg();
    _impl_.argument_.agg_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.ExprArgument.agg)
}
inline ::PicachvMessages::AggExpr* ExprArgument::_internal_mutable_agg() {
  if (argument_case() != kAgg) {
    clear_argument();
    set_has_agg();
    _impl_.argument_.agg_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::AggExpr>(GetArena());
  }
  return _impl_.argument_.agg_;
}
inline ::PicachvMessages::AggExpr* ExprArgument::mutable_agg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::AggExpr* _msg = _internal_mutable_agg();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ExprArgument.agg)
  return _msg;
}

// .PicachvMessages.ColumnExpr column = 2;
inline bool ExprArgument::has_column() const {
  return argument_case() == kColumn;
}
inline bool ExprArgument::_internal_has_column() const {
  return argument_case() == kColumn;
}
inline void ExprArgument::set_has_column() {
  _impl_._oneof_case_[0] = kColumn;
}
inline void ExprArgument::clear_column() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kColumn) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.column_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.column_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::ColumnExpr* ExprArgument::release_column() {
  // @@protoc_insertion_point(field_release:PicachvMessages.ExprArgument.column)
  if (argument_case() == kColumn) {
    clear_has_argument();
    auto* temp = _impl_.argument_.column_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.column_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::ColumnExpr& ExprArgument::_internal_column() const {
  return argument_case() == kColumn ? *_impl_.argument_.column_ : reinterpret_cast<::PicachvMessages::ColumnExpr&>(::PicachvMessages::_ColumnExpr_default_instance_);
}
inline const ::PicachvMessages::ColumnExpr& ExprArgument::column() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ExprArgument.column)
  return _internal_column();
}
inline ::PicachvMessages::ColumnExpr* ExprArgument::unsafe_arena_release_column() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.ExprArgument.column)
  if (argument_case() == kColumn) {
    clear_has_argument();
    auto* temp = _impl_.argument_.column_;
    _impl_.argument_.column_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExprArgument::unsafe_arena_set_allocated_column(::PicachvMessages::ColumnExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_column();
    _impl_.argument_.column_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.ExprArgument.column)
}
inline ::PicachvMessages::ColumnExpr* ExprArgument::_internal_mutable_column() {
  if (argument_case() != kColumn) {
    clear_argument();
    set_has_column();
    _impl_.argument_.column_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::ColumnExpr>(GetArena());
  }
  return _impl_.argument_.column_;
}
inline ::PicachvMessages::ColumnExpr* ExprArgument::mutable_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::ColumnExpr* _msg = _internal_mutable_column();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ExprArgument.column)
  return _msg;
}

// .PicachvMessages.AliasExpr alias = 3;
inline bool ExprArgument::has_alias() const {
  return argument_case() == kAlias;
}
inline bool ExprArgument::_internal_has_alias() const {
  return argument_case() == kAlias;
}
inline void ExprArgument::set_has_alias() {
  _impl_._oneof_case_[0] = kAlias;
}
inline void ExprArgument::clear_alias() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kAlias) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.alias_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.alias_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::AliasExpr* ExprArgument::release_alias() {
  // @@protoc_insertion_point(field_release:PicachvMessages.ExprArgument.alias)
  if (argument_case() == kAlias) {
    clear_has_argument();
    auto* temp = _impl_.argument_.alias_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.alias_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::AliasExpr& ExprArgument::_internal_alias() const {
  return argument_case() == kAlias ? *_impl_.argument_.alias_ : reinterpret_cast<::PicachvMessages::AliasExpr&>(::PicachvMessages::_AliasExpr_default_instance_);
}
inline const ::PicachvMessages::AliasExpr& ExprArgument::alias() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ExprArgument.alias)
  return _internal_alias();
}
inline ::PicachvMessages::AliasExpr* ExprArgument::unsafe_arena_release_alias() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.ExprArgument.alias)
  if (argument_case() == kAlias) {
    clear_has_argument();
    auto* temp = _impl_.argument_.alias_;
    _impl_.argument_.alias_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExprArgument::unsafe_arena_set_allocated_alias(::PicachvMessages::AliasExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_alias();
    _impl_.argument_.alias_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.ExprArgument.alias)
}
inline ::PicachvMessages::AliasExpr* ExprArgument::_internal_mutable_alias() {
  if (argument_case() != kAlias) {
    clear_argument();
    set_has_alias();
    _impl_.argument_.alias_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::AliasExpr>(GetArena());
  }
  return _impl_.argument_.alias_;
}
inline ::PicachvMessages::AliasExpr* ExprArgument::mutable_alias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::AliasExpr* _msg = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ExprArgument.alias)
  return _msg;
}

// .PicachvMessages.WildcardExpr wildcard = 4;
inline bool ExprArgument::has_wildcard() const {
  return argument_case() == kWildcard;
}
inline bool ExprArgument::_internal_has_wildcard() const {
  return argument_case() == kWildcard;
}
inline void ExprArgument::set_has_wildcard() {
  _impl_._oneof_case_[0] = kWildcard;
}
inline void ExprArgument::clear_wildcard() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kWildcard) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.wildcard_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.wildcard_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::WildcardExpr* ExprArgument::release_wildcard() {
  // @@protoc_insertion_point(field_release:PicachvMessages.ExprArgument.wildcard)
  if (argument_case() == kWildcard) {
    clear_has_argument();
    auto* temp = _impl_.argument_.wildcard_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.wildcard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::WildcardExpr& ExprArgument::_internal_wildcard() const {
  return argument_case() == kWildcard ? *_impl_.argument_.wildcard_ : reinterpret_cast<::PicachvMessages::WildcardExpr&>(::PicachvMessages::_WildcardExpr_default_instance_);
}
inline const ::PicachvMessages::WildcardExpr& ExprArgument::wildcard() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ExprArgument.wildcard)
  return _internal_wildcard();
}
inline ::PicachvMessages::WildcardExpr* ExprArgument::unsafe_arena_release_wildcard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.ExprArgument.wildcard)
  if (argument_case() == kWildcard) {
    clear_has_argument();
    auto* temp = _impl_.argument_.wildcard_;
    _impl_.argument_.wildcard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExprArgument::unsafe_arena_set_allocated_wildcard(::PicachvMessages::WildcardExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_wildcard();
    _impl_.argument_.wildcard_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.ExprArgument.wildcard)
}
inline ::PicachvMessages::WildcardExpr* ExprArgument::_internal_mutable_wildcard() {
  if (argument_case() != kWildcard) {
    clear_argument();
    set_has_wildcard();
    _impl_.argument_.wildcard_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::WildcardExpr>(GetArena());
  }
  return _impl_.argument_.wildcard_;
}
inline ::PicachvMessages::WildcardExpr* ExprArgument::mutable_wildcard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::WildcardExpr* _msg = _internal_mutable_wildcard();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ExprArgument.wildcard)
  return _msg;
}

// .PicachvMessages.FilterExpr filter = 5;
inline bool ExprArgument::has_filter() const {
  return argument_case() == kFilter;
}
inline bool ExprArgument::_internal_has_filter() const {
  return argument_case() == kFilter;
}
inline void ExprArgument::set_has_filter() {
  _impl_._oneof_case_[0] = kFilter;
}
inline void ExprArgument::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kFilter) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.filter_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.filter_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::FilterExpr* ExprArgument::release_filter() {
  // @@protoc_insertion_point(field_release:PicachvMessages.ExprArgument.filter)
  if (argument_case() == kFilter) {
    clear_has_argument();
    auto* temp = _impl_.argument_.filter_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::FilterExpr& ExprArgument::_internal_filter() const {
  return argument_case() == kFilter ? *_impl_.argument_.filter_ : reinterpret_cast<::PicachvMessages::FilterExpr&>(::PicachvMessages::_FilterExpr_default_instance_);
}
inline const ::PicachvMessages::FilterExpr& ExprArgument::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ExprArgument.filter)
  return _internal_filter();
}
inline ::PicachvMessages::FilterExpr* ExprArgument::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.ExprArgument.filter)
  if (argument_case() == kFilter) {
    clear_has_argument();
    auto* temp = _impl_.argument_.filter_;
    _impl_.argument_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExprArgument::unsafe_arena_set_allocated_filter(::PicachvMessages::FilterExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_filter();
    _impl_.argument_.filter_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.ExprArgument.filter)
}
inline ::PicachvMessages::FilterExpr* ExprArgument::_internal_mutable_filter() {
  if (argument_case() != kFilter) {
    clear_argument();
    set_has_filter();
    _impl_.argument_.filter_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::FilterExpr>(GetArena());
  }
  return _impl_.argument_.filter_;
}
inline ::PicachvMessages::FilterExpr* ExprArgument::mutable_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::FilterExpr* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ExprArgument.filter)
  return _msg;
}

// .PicachvMessages.BinaryExpr binary = 6;
inline bool ExprArgument::has_binary() const {
  return argument_case() == kBinary;
}
inline bool ExprArgument::_internal_has_binary() const {
  return argument_case() == kBinary;
}
inline void ExprArgument::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline void ExprArgument::clear_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kBinary) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.binary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.binary_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::BinaryExpr* ExprArgument::release_binary() {
  // @@protoc_insertion_point(field_release:PicachvMessages.ExprArgument.binary)
  if (argument_case() == kBinary) {
    clear_has_argument();
    auto* temp = _impl_.argument_.binary_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::BinaryExpr& ExprArgument::_internal_binary() const {
  return argument_case() == kBinary ? *_impl_.argument_.binary_ : reinterpret_cast<::PicachvMessages::BinaryExpr&>(::PicachvMessages::_BinaryExpr_default_instance_);
}
inline const ::PicachvMessages::BinaryExpr& ExprArgument::binary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ExprArgument.binary)
  return _internal_binary();
}
inline ::PicachvMessages::BinaryExpr* ExprArgument::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.ExprArgument.binary)
  if (argument_case() == kBinary) {
    clear_has_argument();
    auto* temp = _impl_.argument_.binary_;
    _impl_.argument_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExprArgument::unsafe_arena_set_allocated_binary(::PicachvMessages::BinaryExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_binary();
    _impl_.argument_.binary_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.ExprArgument.binary)
}
inline ::PicachvMessages::BinaryExpr* ExprArgument::_internal_mutable_binary() {
  if (argument_case() != kBinary) {
    clear_argument();
    set_has_binary();
    _impl_.argument_.binary_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::BinaryExpr>(GetArena());
  }
  return _impl_.argument_.binary_;
}
inline ::PicachvMessages::BinaryExpr* ExprArgument::mutable_binary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::BinaryExpr* _msg = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ExprArgument.binary)
  return _msg;
}

// .PicachvMessages.UnaryExpr unary = 7;
inline bool ExprArgument::has_unary() const {
  return argument_case() == kUnary;
}
inline bool ExprArgument::_internal_has_unary() const {
  return argument_case() == kUnary;
}
inline void ExprArgument::set_has_unary() {
  _impl_._oneof_case_[0] = kUnary;
}
inline void ExprArgument::clear_unary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kUnary) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.unary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.unary_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::UnaryExpr* ExprArgument::release_unary() {
  // @@protoc_insertion_point(field_release:PicachvMessages.ExprArgument.unary)
  if (argument_case() == kUnary) {
    clear_has_argument();
    auto* temp = _impl_.argument_.unary_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.unary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::UnaryExpr& ExprArgument::_internal_unary() const {
  return argument_case() == kUnary ? *_impl_.argument_.unary_ : reinterpret_cast<::PicachvMessages::UnaryExpr&>(::PicachvMessages::_UnaryExpr_default_instance_);
}
inline const ::PicachvMessages::UnaryExpr& ExprArgument::unary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ExprArgument.unary)
  return _internal_unary();
}
inline ::PicachvMessages::UnaryExpr* ExprArgument::unsafe_arena_release_unary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.ExprArgument.unary)
  if (argument_case() == kUnary) {
    clear_has_argument();
    auto* temp = _impl_.argument_.unary_;
    _impl_.argument_.unary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExprArgument::unsafe_arena_set_allocated_unary(::PicachvMessages::UnaryExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_unary();
    _impl_.argument_.unary_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.ExprArgument.unary)
}
inline ::PicachvMessages::UnaryExpr* ExprArgument::_internal_mutable_unary() {
  if (argument_case() != kUnary) {
    clear_argument();
    set_has_unary();
    _impl_.argument_.unary_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::UnaryExpr>(GetArena());
  }
  return _impl_.argument_.unary_;
}
inline ::PicachvMessages::UnaryExpr* ExprArgument::mutable_unary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::UnaryExpr* _msg = _internal_mutable_unary();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ExprArgument.unary)
  return _msg;
}

// .PicachvMessages.LiteralExpr literal = 8;
inline bool ExprArgument::has_literal() const {
  return argument_case() == kLiteral;
}
inline bool ExprArgument::_internal_has_literal() const {
  return argument_case() == kLiteral;
}
inline void ExprArgument::set_has_literal() {
  _impl_._oneof_case_[0] = kLiteral;
}
inline void ExprArgument::clear_literal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kLiteral) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.literal_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.literal_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::LiteralExpr* ExprArgument::release_literal() {
  // @@protoc_insertion_point(field_release:PicachvMessages.ExprArgument.literal)
  if (argument_case() == kLiteral) {
    clear_has_argument();
    auto* temp = _impl_.argument_.literal_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::LiteralExpr& ExprArgument::_internal_literal() const {
  return argument_case() == kLiteral ? *_impl_.argument_.literal_ : reinterpret_cast<::PicachvMessages::LiteralExpr&>(::PicachvMessages::_LiteralExpr_default_instance_);
}
inline const ::PicachvMessages::LiteralExpr& ExprArgument::literal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ExprArgument.literal)
  return _internal_literal();
}
inline ::PicachvMessages::LiteralExpr* ExprArgument::unsafe_arena_release_literal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.ExprArgument.literal)
  if (argument_case() == kLiteral) {
    clear_has_argument();
    auto* temp = _impl_.argument_.literal_;
    _impl_.argument_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExprArgument::unsafe_arena_set_allocated_literal(::PicachvMessages::LiteralExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_literal();
    _impl_.argument_.literal_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.ExprArgument.literal)
}
inline ::PicachvMessages::LiteralExpr* ExprArgument::_internal_mutable_literal() {
  if (argument_case() != kLiteral) {
    clear_argument();
    set_has_literal();
    _impl_.argument_.literal_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::LiteralExpr>(GetArena());
  }
  return _impl_.argument_.literal_;
}
inline ::PicachvMessages::LiteralExpr* ExprArgument::mutable_literal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::LiteralExpr* _msg = _internal_mutable_literal();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ExprArgument.literal)
  return _msg;
}

// .PicachvMessages.ApplyExpr apply = 9;
inline bool ExprArgument::has_apply() const {
  return argument_case() == kApply;
}
inline bool ExprArgument::_internal_has_apply() const {
  return argument_case() == kApply;
}
inline void ExprArgument::set_has_apply() {
  _impl_._oneof_case_[0] = kApply;
}
inline void ExprArgument::clear_apply() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (argument_case() == kApply) {
    if (GetArena() == nullptr) {
      delete _impl_.argument_.apply_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.argument_.apply_);
    }
    clear_has_argument();
  }
}
inline ::PicachvMessages::ApplyExpr* ExprArgument::release_apply() {
  // @@protoc_insertion_point(field_release:PicachvMessages.ExprArgument.apply)
  if (argument_case() == kApply) {
    clear_has_argument();
    auto* temp = _impl_.argument_.apply_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.argument_.apply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PicachvMessages::ApplyExpr& ExprArgument::_internal_apply() const {
  return argument_case() == kApply ? *_impl_.argument_.apply_ : reinterpret_cast<::PicachvMessages::ApplyExpr&>(::PicachvMessages::_ApplyExpr_default_instance_);
}
inline const ::PicachvMessages::ApplyExpr& ExprArgument::apply() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PicachvMessages.ExprArgument.apply)
  return _internal_apply();
}
inline ::PicachvMessages::ApplyExpr* ExprArgument::unsafe_arena_release_apply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PicachvMessages.ExprArgument.apply)
  if (argument_case() == kApply) {
    clear_has_argument();
    auto* temp = _impl_.argument_.apply_;
    _impl_.argument_.apply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExprArgument::unsafe_arena_set_allocated_apply(::PicachvMessages::ApplyExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_argument();
  if (value) {
    set_has_apply();
    _impl_.argument_.apply_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PicachvMessages.ExprArgument.apply)
}
inline ::PicachvMessages::ApplyExpr* ExprArgument::_internal_mutable_apply() {
  if (argument_case() != kApply) {
    clear_argument();
    set_has_apply();
    _impl_.argument_.apply_ =
        ::google::protobuf::Message::DefaultConstruct<::PicachvMessages::ApplyExpr>(GetArena());
  }
  return _impl_.argument_.apply_;
}
inline ::PicachvMessages::ApplyExpr* ExprArgument::mutable_apply() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PicachvMessages::ApplyExpr* _msg = _internal_mutable_apply();
  // @@protoc_insertion_point(field_mutable:PicachvMessages.ExprArgument.apply)
  return _msg;
}

inline bool ExprArgument::has_argument() const {
  return argument_case() != ARGUMENT_NOT_SET;
}
inline void ExprArgument::clear_has_argument() {
  _impl_._oneof_case_[0] = ARGUMENT_NOT_SET;
}
inline ExprArgument::ArgumentCase ExprArgument::argument_case() const {
  return ExprArgument::ArgumentCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace PicachvMessages


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_expr_5fargs_2eproto_2epb_2eh
